{"posts":[{"title":"杀死一只知更鸟读书感悟","content":"最近在闲暇时间读了美国作家哈珀·李的成名作《杀死一只知更鸟》，这是一本越读越能感受到很棒的作品。这个故事讲的是一些关于种族歧视的，故事发生的时期虽然已经距离南北战争很久了，但那时候仍然有一部分人把黑人称为&quot;黑鬼&quot;。其实我在本书更多读到的是关于教养、涵养与勇敢，我最喜欢文中女主人公的父亲-阿迪克斯，在他身上有着优秀的品质与勇敢，对于孩子的影响也很大，这才是真正体会到父母是孩子最好的老师。 小说主要是通过一个5岁的小女孩叙述的，这个小女孩叫斯库特，我觉得写的很好的地方就在于很多地方很巧妙，也留给读者思考的空间，是一个小女孩对当时事物的看法，有时候真的很感叹5岁的时候可以有这些稀奇古怪的想法，好像自己在5岁的时候什么都不会想。故事讲述的是一名作为律师的父亲，在接受了为一名黑人辩护的案件中不断经历身边的人的一些不好的看法，甚至孩子也因此受到同学的冷眼相对，但是父亲始终表现的很绅士，并且勇敢淡然的面对。 关于父亲的涵养，我觉得一个人如果是很有涵养是会影响身边的家人的。小说中的斯库特还有一个哥哥，她们家里还有一个黑人家庭保姆名叫卡波妮，在她们家里的相处的非常融洽，她们一家人完全信任卡波妮，卡波妮也完全觉得自己是家里的一份子，悉心照料，把家里的一切搭理好之余，在两个孩子的教育上也都能有正确的引导。例如文中写到，小女孩叫同学去家里吃饭，在家里吃饭前和这个同学打了一架，然后当这个同学吃了一罐糖浆后，开始抱怨同学，然后卡波妮把斯库特叫到厨房并对她说：“有些人不像我们这样吃饭，可是你不能在饭桌上给人家当面指出来。那孩子是你的客人，就算他要吃桌布，你也要随他便。”然后斯库特说：“他不是客人，他只是一个坎宁安家的人”，然后卡波妮生气的打断到“你给我闭嘴！不管他是谁，只要踏进这家门，就是你的客人。别再让我逮到你又对人家说三道四，好像你有多高贵似的！你们家人也许比坎宁安家的人要好，可是你这样羞辱人家，就是一钱不值！”。所以我觉得孩子能明事理，是离不开身边的教育与影响的，在后面还有两个段落让我很深刻，一个是在卡波妮给她穿了一件干净整洁的衣服的时候，她在做事的时候小心翼翼的怕弄脏了衣服，因为那样卡波妮就会重新在洗烫一遍，而且那时候卡波妮已经够忙了。还有一段是在父亲做了黑人的辩护律师后，斯库特到学校被同学嘲笑，她本想好好修理一顿同学，但是让她不这么做的原因是因为父亲告诉了她不允许因为这件事和别人打架，她答应了，她怕违背答应父亲的话而让父亲伤心。而且我认为阿迪克斯是一个真正的君子，在遇到事情不但沉着冷静，还有勇敢与温情，对任何人或事都很温暖，例如晚上快回到家的时候会提前熄灭汽车的发动机来把车溜回去，就是怕打扰家人。 关于教养以及对孩子的教育上，阿迪克斯也是一个很好的榜样，在孩子去调皮的对邻居做出恶作剧的时候，会告诉孩子要如何尊重别人。还有文中最后父亲不想为了让孩子逃避责任而隐瞒真相所说的话：“你也有孩子，只不过我年龄比你大。等我的孩子长大成人之后，如果我还活着，也已经是个老家伙了，可现在我——如果他们不信任我，也就不会信任任何人。杰姆和斯库特知道当时发生了什么。如果他们听见我在镇上讲的是另一个故事——赫克，那样我就会永远失去他们啊。我绝对不能家里一套外面一套。”有多少家长教育孩子的话连自己都做不到。还有文中当哥哥杰姆因为法庭的不公平判决而对斯库特发火的时候，父亲对女儿说：“杰姆在努力忘掉一些事情，可实际上只是暂时放在一边。等过一段时间，他就会重新思考这一切，把事情想个明白。等他可以灵境思考问题的时候，就会恢复自己原来的样子”。我觉得这段话充分体现了父亲是理解孩子当时的心情，而在遇到这种事情的时候父亲的态度不是逃避也不是欺骗自己，而且自己去努力，然后把努力的结果告诉孩子们，在有希望的时候就告诉孩子们有希望，在不需要担心的时候就告诉孩子还不是该担心的时候。 最后我要说的是关于勇敢，我认为文中的阿迪克斯，是不想接这个辩护黑人的案子的，但是在他接了之后，并了解的真想之后，在当时周围的部分人都对他冷言冷语的情况下，他依然义无反顾的去维护黑人，去维护正义，并在接受到不公平的判决与威胁之后依然要上诉\b，我觉得无论是舆论、威胁还是其他因素下都需要很大的勇气来面对，而且她知道他这么做会带来的可能是失败与别人的议论，或者是更大的风波。正是因为父亲的勇敢，所以孩子们也是勇敢的，在父亲面临危险的时候勇敢的冲出去维护自己的父亲，在父亲忙的时候不让父亲担心来自己面对该面对的事。 其实文中还有很多人物和值得我们深思的地方，本文是想给自己做一个读书笔记与感悟。 ","link":"http://xuanguofeng.com/post/ssyzzgn/"},{"title":"问题日志-RecyclerView在notify时焦点丢失","content":"在进行TV开发的时候经常需要处理焦点问题。最近发现在RecyclerView列表中如果需要更新数据的时候，也就是调用notifyDataSetChanged的时候，会导致焦点丢失。 解决办法 @Override public long getItemId(int position) { return position; } 在adapter中重写getItemId方法。 mListAdapter.setHasStableIds(true); 然后调用adapter的setHasStableIds方法传入true，就能解决。 ","link":"http://xuanguofeng.com/post/recyclerview/"},{"title":"EventBus源码分析","content":"EventBus is an open-source library for Android and Java using the publisher/subscriber pattern for loose coupling. EventBus enables central communication to decoupled classes with just a few lines of code – simplifying the code, removing dependencies, and speeding up app development. 这是来自官网的一段介绍。 使用 其实使用很简单，大概就是四个步骤。 步骤一：注册 EventBus.getDefault().register(this); 步骤二：编写接收事件代码 @Subscribe(threadMode = ThreadMode.MAIN) public void onEvent(String message) { mTextView.setText(message); } 步骤三：在需要的地方发送事件 EventBus.getDefault().post(&quot;这是一个事件，可以是Object，接收方将会接收&quot;); 步骤四：注销 EventBus.getDefault().unregister(this); 源码 既然主要分为了上面的四个步骤，所以源码可以从四个步骤方面入手。 初始化 首先所有的流程都要先调用EventBus.getDefault()。 static volatile EventBus defaultInstance; public static EventBus getDefault() { if (defaultInstance == null) { synchronized (EventBus.class) { if (defaultInstance == null) { defaultInstance = new EventBus(); } } } return defaultInstance; } 这里看到是一个单例模式，而且也使用volatile关键字，主要是保证并发时候的可见性。看EventBus的构造也能发现是使用了builder模式来创建EventBus。 register注册 public void register(Object subscriber) { Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);//根据当前注册对象查找这个对象相关的订阅方法 synchronized (this) { for (SubscriberMethod subscriberMethod : subscriberMethods) { subscribe(subscriber, subscriberMethod);//循环将注册类与订阅方法创建订阅关系 } } } 这段代码其实包含一个重要的类就是：subscriberMethodFinder，订阅方法的查找类，register的时候先查找订阅方法，这个订阅方法其实就是我们在注册的类里面通过@Subscribe注解产生的方法。 List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) { List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);//先从缓存中查找 if (subscriberMethods != null) { return subscriberMethods;//缓存中有的话直接返回 } if (ignoreGeneratedIndex) {//通过getDefault默认为false subscriberMethods = findUsingReflection(subscriberClass);//通过反射查找 } else { subscriberMethods = findUsingInfo(subscriberClass);//从index中查找，这里只有通过实现EventBusBuilder的addindex方法时才会有，否则默认还是会通过反射查找。 } if (subscriberMethods.isEmpty()) {//判断如果订阅方法为空的话将会抛出异常。 throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); } else {//不为空的话 添加到缓存中。 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; } } 这个方法其实主要是判断怎么查找订阅方法，其实多数情况还是通过反射查找。这里有一个需要注意的就是如果我们注册了，如果没有通过 @Subscribe(threadMode = ThreadMode.MAIN)这种注解添加订阅方法，会抛出EventBusException异常。如下 接下来主要分析从反射中查找订阅方法 private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) { //代码省略主要调用 findUsingReflectionInSingleClass方法。 } private void findUsingReflectionInSingleClass(FindState findState) { Method[] methods; try { // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); } catch (Throwable th) { // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; } //前面主要是通过反射根据注册的类获取方法数组。 for (Method method : methods) {//循环所有方法 int modifiers = method.getModifiers();//获取方法的修饰符 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) { Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();//获取参数类型 if (parameterTypes.length == 1) {//如果一个参数的话继续，否则会报错 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);//获取定义的注解 if (subscribeAnnotation != null) {//如果能正常获取到注解 Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) { ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky()));//如果检查正常的话将会创建一个SubscriberMethod添加到findState里面的订阅方法集合 } } } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) { String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); } } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) { String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); } } } 由于strictMethodVerification如果通过getDefault()方式的话默认为false所以不会走后面的代码。SubscriberMethod这个类很明显就是对应一个订阅的方法包括一些属性。 public class SubscriberMethod { final Method method;//方法 final ThreadMode threadMode;//线程类型对应POSTING、MAIN、MAIN_ORDERED、BACKGROUND、ASYNC final Class&lt;?&gt; eventType;//在反射时候获取的参数类型 final int priority;//优先级 final boolean sticky;//是否是粘性事件 /** Used for efficient comparison */ String methodString; //省略后面代码。。。 再回来看register里面有一个循环订阅的过程，也就是subscribe()这个方法。 // Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) { Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod);//Subscription其实就是根据注册对象和方法创建的一个订阅关系的维护类，里面重写了equals和hashCode方法。 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);//subscriptionsByEventType是一个订阅者队列 if (subscriptions == null) {//里面没有订阅者的话创建一个队列并根据key添加subscriptions subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); } else { if (subscriptions.contains(newSubscription)) {//如果包含了抛出异常 throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); } } int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) { if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) { subscriptions.add(i, newSubscription);//根据优先级将订阅关系添加到队列中 break; } } List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);//typesBySubscriber保存的是订阅者与订阅者的事件的map，后续通过这个解除注册和判断是否注册 if (subscribedEvents == null) { subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); } subscribedEvents.add(eventType);//将事件添加到事件队列中 if (subscriberMethod.sticky) {//如果是粘性事件 将会立即发送执行 if (eventInheritance) { // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) { Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) { Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); } } } else { Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); } } } 粘性事件主要就是可以先发送，然后在注册的话也可以直接收到事件。其实整个注册流程就是将时间添加到队列中，不过这里的队列也不止一个。这里有几个比较重要的概念后面也要用的到。 post发送事件 public void post(Object event) { PostingThreadState postingState = currentPostingThreadState.get();//通过ThreadLocal维护一个PostingThreadState里面有对应的queue List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event);//将event事件添加到事件队列中 if (!postingState.isPosting) {//isPosting默认为false postingState.isMainThread = isMainThread();//判断当前线程是否主线程并保存状态 postingState.isPosting = true; if (postingState.canceled) {//判断状态是否被canceled throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); } try { while (!eventQueue.isEmpty()) {//循环消息队列不断调用postSingleEvent postSingleEvent(eventQueue.remove(0), postingState);//这里用的是remove也就是说事件执行一个移除一个 } } finally { postingState.isPosting = false; postingState.isMainThread = false; } } } 这个方法主要是创建对应的PostingThreadState，这是一个简单的对象，可以理解为线程发送状态然后里面有一个消息队列和一些状态值。PostingThreadState是通过ThreadLocal保存的，也就是说是和线程绑定的。下面看postSingleEvent方法： private void postSingleEvent(Object event, PostingThreadState postingState) throws Error { Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false;//保存是否能找到订阅关系的标记 if (eventInheritance) {//默认为true 是否支持继承关系 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) { Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);//通过postSingleEventForEventType方法发送事件 } } else {//如果false不查找继承关系 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); } if (!subscriptionFound) { if (logNoSubscriberMessages) { logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass); } if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) { post(new NoSubscriberEvent(this, event)); } } } private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) { CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) { subscriptions = subscriptionsByEventType.get(eventClass);//subscriptionsByEventType之前在注册的时候保存的订阅者队列，在这里根据key查询到这个事件的所有订阅者 } if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) { for (Subscription subscription : subscriptions) {//迭代所有的订阅者维护postingState postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try { postToSubscription(subscription, event, postingState.isMainThread);//根据subscription和事件 去进行线程分发然后调用 aborted = postingState.canceled; } finally { postingState.event = null; postingState.subscription = null; postingState.canceled = false; } if (aborted) { break; } } return true; } return false; } private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) { switch (subscription.subscriberMethod.threadMode) { case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) { invokeSubscriber(subscription, event); } else { mainThreadPoster.enqueue(subscription, event); } break; case MAIN_ORDERED: if (mainThreadPoster != null) { mainThreadPoster.enqueue(subscription, event); } else { // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); } break; case BACKGROUND: if (isMainThread) { backgroundPoster.enqueue(subscription, event); } else { invokeSubscriber(subscription, event); } break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); } } 上面这段代码其实就是根据之前绑定的Subscription里的Method判断线程模式，然后根据不同的方式处理事件，其实这几种方式主要是通过Poster的实现类。 主要是有4种方式：反射直接调用、在主线程发射事件、在单独子线程发送、异步发送。其实无论哪种方式最后都是通过invokeSubscriber()方法返回到Eventbus通过反射调用，只不过通过Handler、链表、队列和线程池等技术手段实现在在后台或者主线程执行。其实线程池在EventBusBuilder中已经在初始化的时候就创建了。 void invokeSubscriber(Subscription subscription, Object event) { try { subscription.subscriberMethod.method.invoke(subscription.subscriber, event); } catch (InvocationTargetException e) { handleSubscriberException(subscription, event, e.getCause()); } catch (IllegalAccessException e) { throw new IllegalStateException(&quot;Unexpected exception&quot;, e); } } 这就是最终通过反射调用方法。 解注册 /** Unregisters the given subscriber from all event classes. */ public synchronized void unregister(Object subscriber) { List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) { for (Class&lt;?&gt; eventType : subscribedTypes) { unsubscribeByEventType(subscriber, eventType); } typesBySubscriber.remove(subscriber); } else { logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass()); } } 其实解注册主要就是在之前分析的typesBySubscriber集合和subscriptionsByEventType集合根据subscriber移除掉。 总结 其实文章中有一些细节没有写出来，不过笔者已经看过了，建议读者自己也想想有什么问题去看看，这里分析的是基本流程。 EventBus感觉可以分开两个词Event Bus，而且主要还是以EventBus这类为主延伸出来的一些处理类，比如SubscriberMethodFinder、EventBusBuilder，Poster等等，然后又回到EventBus来处理相关的逻辑。 Thanks Android 框架学习：源码分析 EventBus 3.0 如何实现事件总线 ","link":"http://xuanguofeng.com/post/eventbus-yuan-ma-fen-xi/"},{"title":"问题日志-Fresco库的libimagepipeline.so问题","content":"使用了Fresco的图片库会发现在部分机型上会报java.lang.UnsatisfiedLinkError: couldn't find DSO to load: libimagepipeline.so caused by: dlopen failed: &quot;/data/data/cn.krcom.tv/lib-main/libimagepipeline.so&quot; is 64-bit instead of 32-bit错误。 问题描述 java.lang.UnsatisfiedLinkError: couldn't find DSO to load: libimagepipeline.so caused by: dlopen failed: &quot;/data/data/cn.krcom.tv/lib-main/libimagepipeline.so&quot; is 64-bit instead of 32-bit at com.facebook.soloader.SoLoader.initSoSources(SoLoader.java) doLoadLibraryBySoName(SoLoader.java) makeNonZipPath(SoLoader.java) getNativeLoadRuntimeMethod(SoLoader.java) at com.facebook.soloader.SoLoader.init(SoLoader.java) loadLibrary(SoLoader.java) init(SoLoader.java) makePrepareFlags(SoLoader.java) loadLibraryBySoName(SoLoader.java) initSoLoader(SoLoader.java) //后面的省略了 原因与解决 首先有一句log很重要那就是“libimagepipeline.so caused by: dlopen failed: &quot;/data/data/cn.krcom.tv/lib-main/libimagepipeline.so&quot; is 64-bit instead of 32-bit”这里的信息能看出来主要是libimagepipeline.so的so文件引起的。 所以主要考虑是cpu指令集与so文件的兼容问题。其实大部分so是相互兼容的，但是查看项目发现里面同时有arm64-v8a文件夹和armeabi-v7a，所以通过解析apk发现里面的so对应的不一样。所以发现在arm64-v8a的设备上先找到了里面的so，如果有些三方库支持的so文件夹不一致就会导致crash。 所以要解决的话首先要保证支持的目录里的so文件是一样的。或者可以只使用一个兼容的文件夹。 参考文章： https://developer.android.com/ndk/guides/abis https://blog.csdn.net/u013531824/article/details/53931307 https://www.jianshu.com/p/ad95c885c2f8 ","link":"http://xuanguofeng.com/post/wen-ti-ri-zhi-fresco-ku-de-libimagepipelineso-wen-ti/"},{"title":"问题日志-低版本Didn't find class \"~FileProvider\"","content":"由于在低版本的系统中，会提示Didn't find class &quot;android.support.v4.content.FileProvider&quot;问题，所以查找了下解决方案。 问题描述 由于在项目中使用了provider，并如下配置 &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;${applicationId}.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt; &lt;/provider&gt; 而且由于项目中的方法数大于65536，所以要在defaultConfig中使用如下方式进行对dex拆分打包 multiDexEnabled true 这样就可能会导致如下问题： Caused by: java.lang.ClassNotFoundException: Didn't find class &quot;android.support.v4.content.FileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/cn.krcom.tv.beta-1.apk&quot;],nativeLibraryDirectories=[/data/app-lib/项目的包名-1, /system/lib]] at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56) at java.lang.ClassLoader.loadClass(ClassLoader.java:497) at java.lang.ClassLoader.loadClass(ClassLoader.java:457) at android.app.ActivityThread.installProvider(ActivityThread.java:4762) at android.app.ActivityThread.installContentProviders(ActivityThread.java:4369) at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4309) at android.app.ActivityThread.access$1500(ActivityThread.java:135) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1256) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:136) at android.app.ActivityThread.main(ActivityThread.java:5001) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:515) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:785) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601) at dalvik.system.NativeStart.main(Native Method) 原因与解决方式 于是就查找问题，其实原因在官方文档的分包方法中早已写明。也说明了原因 配置您的应用进行 Dalvik 可执行文件分包 主要解决办法就是 引入multidex compile 'com.android.support:multidex:1.0.3' 在Application中初始化 public class MyApplication extends MultiDexApplication { ... } 或者直接调用 MultiDex.install(this); ","link":"http://xuanguofeng.com/post/【问题日志】低版本dex拆分问题/"},{"title":"AsyncTask源码解析","content":"AsyncTask是用来在实现在子线程执行任务后切换到UI线程，常见的比如下载任务的更新，执行下载后在UI线程实时更新进度条。由于是基本的API所以还是很有必要了解源码的。 使用 使用其实也很简单，主要是实现AsyncTask类，然后执行excute方法。其中有3个参数和4个方法是必须要掌握的。 private class MyAsyncTask extends AsyncTask&lt;String, String, String&gt; { @Override protected void onPreExecute() { super.onPreExecute(); } @Override protected void onPostExecute(String s) { super.onPostExecute(s); } @Override protected void onProgressUpdate(String... values) { super.onProgressUpdate(values); } @Override protected String doInBackground(String... strings) { return null; } } onPreExecute 这个方法是在UI线程执行，并且在后台任务开始前执行。 doInBackground 这个在线程执行，这里主要是做耗时任务。这个方法有参数和返回值，参数就是在调用execute传进来的参数，返回值就是我们经过一些列操作后返回给onProgressUpdate方法的，主要用于UI的更新。例如我下载到50%然后同志UI实时更新。 onProgressUpdate 从方法名看就是更新进度，这个参数就是doInBackground中返回的。 onPostExecute 这个方法就是任务执行完成后要执行的方法。参数也是执行的结果。 三个参数 掌握了这4个方法，这三个参数就很容易理解了。 第一个，是传入的参数。 第二个，是执行任务时进度更新的值。 第三个，任务执行结束的返回值。 源码 其实源码无非就是看内部的核心机制，和这几个方法的调用流程。最直观的就从execute方法开始。 @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } 这里直接调用了executeOnExecutor，传入了sDefaultExecutor和参数。 @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; } 先看下这个函数里面都做了什么，在分析sDefaultExecutor。executeOnExecutor这个函数是public的所以我们也可以直接通过这个函数执行任务。如果我们通过executeOnExecutor()这个方法的话就要自己创建一个Executor，因为默认的Executor是使用队列维护同时只有一个线程执行任务，多任务时会被添加到队列中，后面会讲到。 首先，进来先判断状态，如果如果不是没执行过的要抛出异常，这就是为什么如果执行两次任务会报java.lang.IllegalStateException这个错的原因。 其次，将状态改为正在执行。 然后，执行onPreExecute()方法，这就是为什么这个方法在主线程，而且在任务前执行。 再然后开始执行Executor的任务，这时候我们可以分析sDefaultExecutor了。 类里可以看到 private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 这两个常量其实就是默认创建了一个Executor private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 这个SerialExecutor里面维护了一个队列，然后通过offer()在队列的末尾加入任务，通过poll()在头部检索出任务并删除，检索后赋值给mActive。因为首次mActive为null，所以加入了判断mActive==null的时候执行scheduleNext(),后面再有任务来的话mActive就不是null了，所以是在runable中，通过finally调用了scheduleNext()，这时候就会等任务执行完成后在执行下一个任务。这就是上面说的为什么默认的SerialExecutor只能同时在一个线程执行任务。 /** * An {@link Executor} that can be used to execute tasks in parallel. */ public static final Executor THREAD_POOL_EXECUTOR; static { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; } 这个主要就是通过各种默认为的参数创建了一个线程池去执行任务。 这就是主要流程，但是在这个流程中还忽略了很多内容，在我们了解了整体框架流程后，在去填充我们想知道的细节，就更容易理解了。 首先看executeOnExecutor()方法中有两个很重要的内容一个是mWorker和mFuture。其实执行任务的时候传入了mFuture，而mFuture是一个mFutureTask真正执行的是mWorker。 /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { this((Looper) null); } /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. * * @hide */ public AsyncTask(@Nullable Handler handler) { this(handler != null ? handler.getLooper() : null); } /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. * * @hide */ public AsyncTask(@Nullable Looper callbackLooper) { mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Result result = null; try { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); } catch (Throwable tr) { mCancelled.set(true); throw tr; } finally { postResult(result); } return result; } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } 在构造里创建了三部分内容，mHandler、mWorker、mFutur 可以看到首先会创建handler因为，线程通信还是需要依靠Handler。然后mWorker中主要就是执行doInBackground()然后将result传给postResult。 private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } postResult主要就是通过handler发送一个what为MESSAGE_POST_RESULT，obj为result的message。 private static class InternalHandler extends Handler { public InternalHandler(Looper looper) { super(looper); } @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } 这时候看handleMessage是怎么处理的。 这里主要是调用区分what是完成还是未完成完成的话就是调用finish方法，未完成就是onProgressUpdate方法， private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 在看finish方法就是判断是否取消然后调用onPostExecut方法将结果传入。 hadlerMessage还处理一个就是更新进度，那这个message是在哪里发的呢？ protected final void publishProgress(Progress... values) { if (!isCancelled()) { getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); } } 可以看到是通过publishProgress这个方法，所以我们如果需要更新进度的话要自己在doInBackground这个方法里调用publishProgress()方法传入进度。然后在才会在onProgressUpdate()这个方法中收到。 总结 至此 整个流程也就清晰了，这四个方法是分别在哪里调用的在能实现异步然后更新UI的功能，其实原理很简单，就是用了一个线城池然后我们在子线程实时通过Handler发送Message到UI线程中执行进度的任务，默认通过一个队列维护任务，也可以自定义Executor来实现多线程执行任务。 ","link":"http://xuanguofeng.com/post/AsyncTask源码解析/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 𝖶𝗂𝗇𝖽𝗈𝗐𝗌 或 𝖬𝖺𝖼𝖮𝖲 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"http://xuanguofeng.com/post/hello-gridea/"},{"title":"【Flutter笔记】之Widget的一些总结","content":"可以说flutter中是基于Widgets的，一个TextView是Widgets，一个布局也是一个Widgets。使用Widgets去组装出你想要的 UI，了解Widgets也是非常重要的。 Flutter默认也提供了丰富我Widgets，包括Android Material Design风格的控件，也有iOS风格的Cupertino组件库。而且所有组件的使用方式几乎是一样的，所以在写UI的时候只要对这些组件进行组装即可。 一些常用组件的常用用法。 import 'package:flutter/material.dart'; void main() { runApp( new Center( child: new Text( 'Hello, world!', textDirection: TextDirection.ltr, ), ), ); } 这是一段hello word代码，首先 runApp 是程序的入口，接下来便是一个Widgets，Center这是一布局 Widgets,然后里面是一个Text Widgets。 在Flutter中就是这样的，可能不是所有Widgets都有通用的方法，但是可以通过包裹嵌套来实现。例如 text默认没有事件，可以通过事件Widgets进行嵌套实现。 StatelessWidget 和 StatefulWidget 我们写的控件基本都要继承这两个，这两个的主要区别是看页面是否需要动态刷新，建议不需要刷新时使用StatelessWidget，如果需要刷新的话可以使用StatefulWidget并通过调用setState来通知框架改变状态。 里面的build函数式 widgets 的入口函数，可以在里面创建其他的widgets。框架将会一次构建这些widgets，直到最底层的 RenderObject 之下，然后计算机进行计算相关的图形并渲染出。 一些常用Wigets 由于Widgets的样式以及用法，之前总结了一个单独的demo，大家可以看demo，里面有展示以及代码具体实现。 地址：https://github.com/xuanguofeng/flutter_widgets 常用Widgets Flutter内置了丰富的常用的组件，包括文本、按钮、图片、行、列等组件。 Material Design风格Widgets Flutterd对Material Design的支持很丰富，也提供了市面目前比较流行的风格，比如Android的侧滑、底部的导航等，具体可以看本文地下的demo。 Cupertino的iOS风格组件 这里也是举了一些控件的名称，对iOS的支持也很丰富，包含常用的title样式、底部导航、iOS风格的按钮、Dialod、加载中的loading等。 Layout Widgets Layout的控件是比较常用的，因为好多功能要通过嵌套来实现。例如 margin、padding、事件的widgets、material design风格的布局、类似帧布局的Stack、GridView、ListView、Center、Align等。 其他还有很多控件，可以参考官方文档。 文档地址：http://doc.flutter-dev.cn/widgets/ ","link":"http://xuanguofeng.com/post/【Flutter笔记】之Widget的一些总结/"},{"title":"问题日志-Flutter页面跳转无反应的问题","content":"描述：在使用Flutter做页面跳转时候，官方的描述使用方法是这样的。 void main() { runApp(new MaterialApp( home: new MyAppHome(), // becomes the route named '/' routes: &lt;String, WidgetBuilder&gt; { '/a': (BuildContext context) =&gt; new MyPage(title: 'page A'), '/b': (BuildContext context) =&gt; new MyPage(title: 'page B'), '/c': (BuildContext context) =&gt; new MyPage(title: 'page C'), }, )); } 接着就可以通过如下方式来操作 Route。 Navigator.of(context).pushNamed('/b'); 看一些代码确实也是这样使用的，但是之前自己使用的时候就是无法跳转。 提示： The context used to push or pop routes from the Navigator must be that of a widget that is a descendant of a Navigator widget. 解决步骤 上网查询资料，此时Flutter的资料还不是很多。 解决方法 class _FWMainAppState extends State&lt;FWMainApp&gt; { @override Widget build(BuildContext context) { return MaterialApp( theme: ThemeData( primaryColor: AppColors.colorPrimary, accentColor: Colors.blue), home: _Home(), routes: &lt;String, WidgetBuilder&gt;{ '/BtnSamplePage': (BuildContext context) =&gt; BtnSamplePage(), '/TextSamplePage': (BuildContext context) =&gt; TextSamplePage(), '/DialogSamplePage': (BuildContext context) =&gt; DialogSamplePage(), '/LayoutSamplePage': (BuildContext context) =&gt; LayoutSamplePage(), }, ); } } 主要看home:由于这是首页之前在home是直接创建的控件，一直提示失败。 后来通过home：后面引入一个类，在类里创建想要创建的控件就解决了。 class _Home extends StatelessWidget { @override Widget build(BuildContext context) { return new Scaffold( appBar: AppBar( title: Text(AppStrings.appBarTitle), actions: &lt;Widget&gt;[ new IconButton( icon: const Icon(Icons.build), onPressed: () async {}, tooltip: 'tool', ) ], ), body: _body, ); } } ","link":"http://xuanguofeng.com/post/问题日志-Flutter页面跳转无反应的问题/"},{"title":"【Flutter笔记】之Dart与Java的一些直观区别","content":"Dart 是 Flutter 的主要开发语言，Flutter 是一个来自 Google 用于移动应用开发的 SDK。其实对于Java开发人员来说Dart，还是相对好理解的，这篇笔记将记录初学Dart时，相比较Java的一些区别。 ##区别 构造函数 在Dart的构造中可以没有方法体。 //这样写很简单 User(this.cadence, this.speed, this.gear); //也可以写成这样 Bicycle(int cadence, int speed, int gear) { this.cadence = cadence; this.speed = speed; this.gear = gear; } 可选参数 在Dart中可以使用可选参数、无论是构造还是普通方法。 Book({this.money = 100, this.size = 0, this.author = null}); 调用的时候要指定参数名 main() { print(Book(money:100 , size: 88, author:'test')); print(Book(money:99, size:100)); print(Rectangle()); } 关键字 在 Dart 中没有诸如 public、private、protected 这样的关键词。 如果一个标识符以 (_) 开头，则该标识符 在库内是私有的 Dart2中，可以不使用new关键字创建，也可以使用。 变量 Dart中变量初始值为null，即使是int类型也是null。 Dart支持自识别，可以是用var定义变量，也可以直接指定具体类型。 如果你以后不打算修改一个变量，使用 final 或者 const。 一个 final 变量只能赋值一次；一个 const 变量是编译时常量。 基本类型 int和double是num的子类。没有float类型。 Dart中所有的类都是Object的子类。 String可以使用单引号或者双引号。 String支持模板，使用 ${expression} 的方式来实现字符串模板的效果，如果该表达式仅仅是一个标识符，还可以去掉花括号 $variableName。 字符串前加r代表原始字符串。 只有true和flase是bool类型，这两个对象也是编译时常量。当Dart需要一个布尔值的时候，只有true对象才被认为true,其他都是false。 方法 Dart是一个真正面向对象的语言，方法也是对象并且具有一种类型Function。 可以使用上文说的可选方法。 支持直接设置默认参数值。 所有函数都返回一个值，如果没有指定返回值，则 默认把语句 return null; 作为函数的最后一个语句执行。 可以把方法当做参数调用另一个方法。 printElement(element) { print(element); } var list = [1, 2, 3]; // Pass printElement as a parameter. list.forEach(printElement); 方法也可以赋值给一个变量 var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!'; assert(loudify('hello') == '!!! HELLO !!!'); 操作符 ?? expr1 ?? expr2 如果 expr1 是 non-null，返回其值； 否则执行 expr2 并返回其结果。 .? 可以避免表达式左边对象为null时候抛出异常。 级联操作符,级联操作符 (..) 可以在同一个对象上 连续调用多个函数以及访问成员变量。 querySelector('#button') // Get an object. ..text = 'Confirm' // Use its members. ..classes.add('important') ..onClick.listen((e) =&gt; window.alert('Confirmed!')); 类型判定操作符 as、 is、 和 is! 操作符是在运行时判定对象 类型的操作符： as 类型转换 is 如果对象是指定的类型返回 True is! 如果对象是指定的类型返回 False 只有当 obj 实现了 T 的接口， obj is T 才是 true。例如 obj is Object 总是 true。 断言 Dart中支持assert这个断言方法。如果方法结果true,继续执行，如果false则抛出异常。这个方法在正式包中将不执行。 // assert(条件); ##总结 Dart和Java还是很相似的，对于Java程序员也是相对容易上手的，由于现在是初学，只总结了一些常用的，当然区别远远不止这些，总结大多是Dart中有的Java中没有的东西，会不断补充。 ","link":"http://xuanguofeng.com/post/【Flutter笔记】之Dart与Java的一些直观区别/"},{"title":"【Flutter笔记】之Flutter的理解","content":"目前对Flutter的理解还是很少的，只是想作为一个笔记，在不断理解的基础上进行不断的修改与完善，查漏补缺，看看自己学之前与学之后是的理解是一个什么状态。 Flutter介绍 Flutter 是谷歌的移动端 UI 框架，可在极短的时间内构建 Android 和 iOS 上高质量的原生级应用。 Flutter 可与现有代码一起工作, 它被世界各地的开发者和组织使用, 并且 Flutter 是免费和开源的. 这是官网的介绍，大标题是“以极短的时间构建优雅的原生级应用”，可以了解到Flutter是一个框架，通过这个框架可以使用Dart语言通过一套代码构建Android和iOS应用程序。 Flutter里面同时提供了两种UI库的风格，第一种肯定是Material Design风格，还要就是Cupertino风格，也就是iOS中采用的风格。 个人理解应该是Flutter封装了一套完整的UI的API，在开发时候可以直接使用，通过官网介绍了解应该也可以直接调用Android和iOS中的原生API。 为什么使用Dart语言？ 个人对其他语言并没有了解那么深，这个问题只是说下自己的想法和在网上查到的一些人的见解。 首先我一眼看上去，感觉Dart的格式并不友好，相比Kotlin觉得更是可读性差很多，据知乎上一位大神说和Flutter的工程师咨询，是因为Dart的团队距离他们很近，能很好的得到支持，不知道是否玩笑。用Dart代码写页面还是很容易理解的，至于与mxl相比哪种方式更好现在我还体会不好，因为还没有深度是使用Dart。 Dart同时支持AOT编译和JIT编译，Dart的编译和执行不仅非常灵活，而且速度很快。还有我觉得Dart是相对容易学习的。用Flautter的时候还支持热重载，这相比Instant Run的体验要好很多的，确实提高了效率，不会因为只改了一点页面而编译好久的状况。Dart是基于单线程模型的语言，但是也有自己的机制叫isolate。之间无法直接共享内存，这也就是避免了大部分使用锁的情况。 还有就是这是Google自己的语言，也是开源的，不会惹出88亿美元的的官司吧。总体感觉通过了解，还是一门很优秀的语言，而且在Google内外据说也得到很好的使用，而且随着Flutter以及新系统的推出，这门语言也有可能越来越好，不过后面情况谁也说不好，还要看Google怎么支持与推广。 Flutter是如何渲染界面的？ 移动设备中有GPU和CPU，一般是GPU控制将数据渲染到显示设备上的，GPU主要是通过发出VSync同步信号去帧数据来传递给显示器。 FPS表示每秒传递的帧数，我们知道在理想情况下60FPS就感觉不到爱看，这意味着每个绘制时长应该在16ms以内，Android系统每隔16ms发出VSync信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到刘畅的画面所需的60FPS。如果某个操作花费四件比较吃长 比如用了30ms，系统在得到VSync信号时就无法进行正常渲染，这样就发生了丢帧现象，就会感觉卡顿。 所以玩游戏的时候需要更好的CPU与GPU的支持。 Flutter只关心向GPU提供视图数据，只关心VSync信号，然后通过Google自己的Skia渲染引擎想GPU提供数据。所以说Flutter是直接通过Skia自己进行渲染，而不是调用某些API，这也是Flutter一直宣称原生体验的原因。 Flutter前景如何，是否值得学习？ 这个每个人的看法不同，个人认为前景还可以，与React Native原理不同，Flutter是通过自己渲染，可能会体验会更好。使用Dart语言，这门语言目前看来说对于有编程经验的人来说可能还是相对容易些的，而支持库目前来看也还可以，也要看Google后续的动作吧。 对于公司来说如果维护一套代码来实现两个端无疑时间好事，从节约成本、到方便维护、界面统一都是很好的，但是Flutter商用应该仍有一段距离吧。 如果有时间又有兴趣的话，可以搞一下的，毕竟程序员就是在不断学习的道路上。 ","link":"http://xuanguofeng.com/post/【Flutter笔记】之Flutter的理解/"},{"title":"【Flutter笔记】之环境搭建","content":"Flutter 是 Google 用以帮助开发者在 iOS 和 Android 两个平台开发高质量原生 UI 的移动 SDK。Flutter 兼容现有的代码，免费且开源。使用Dart语言。 基于Android Studio环境搭建 支持flutter的IDE 目前有Android Studio、 IntelliJ、Visual Studio。 安装 Flutter 和 Dart 插件 在Android Studio中安装这两个插件。 Flutter 插件可以提高 Flutter 在开发过程中的开发效率（运行，调试，热重载等等）。 Dart 插件提提升了代码层面的开发效率（在你敲代码的同时进行代码校验，代码自动补全等等）。 安装步骤 启动 Android Studio。 打开插件设置（在 macOS 上路径为 Preferences&gt;Plugins，在 Windows 和 Linux 上路径为 File&gt;Settings&gt;Plugins）。 当弹出对话框提示要安装 Dart 插件的时候，点击 Yes 接受。 如果弹出 Restart 需要重启编辑器的时候，点击 Yes 接受。 【注意】 第一次运行时候要选择指定的文件夹，然后点击install SDK 来安装Flutter SDK环境，可能需要下载一会。 Hello Word 在Android Studio中创建项目的时候会有New Flutter Project选项这时候如果本地没有Flutter环境的话 会让你下载。 创建后可以看到IDE的右上角有些功能按钮。 可以看到这里不但有Android的目录，还有iOS的目录，运行的时候如果有iOS设备以及模拟器的话 是可以直接选择运行的。 右侧闪电的标志支持热重载编译运行。 由于我是mac电脑，特意选了一个iOS模拟器，在Android Studio直接运行在iOS设备上还是很爽的。 ","link":"http://xuanguofeng.com/post/【Flutter笔记】之环境搭建/"},{"title":"Android热门开源框架-OkHttp源码探究五","content":"前面基本介绍了OkHttp的流程以及源码，这里看最后一个重要的核心源码OkHttp中的拦截器。 拦截器机制 拦截器是OkHttp中一个强大的机制，能实现网络监听，请求以及响应重写，请示失败重试等功能。 拦截器链 getResponseWithInterceptorChain 方法 之前说到主要是通过这个方法来返回response那么来看看这个方法里究竟是做了什么呢 Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); } 首先添加自定义配置的拦截器 然后以此添加系统内置的拦截器 然后创建RealInterceptorChain并把这个集合添加进去，这个就是个拦截器链 通过chain.proceed(originalRequest);这个方法执行 proceed这个方法也很重要 可以看一下 public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException { if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) { throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1) + &quot; must retain the same host and port&quot;); } // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) { throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1) + &quot; must call proceed() exactly once&quot;); } //注意处 // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) { throw new IllegalStateException(&quot;network interceptor &quot; + interceptor + &quot; must call proceed() exactly once&quot;); } // Confirm that the intercepted response isn't null. if (response == null) { throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;); } if (response.body() == null) { throw new IllegalStateException( &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;); } return response; } 这里主要看标注的注意处 这里主要通过index+1创建了下一个拦截器，也就行程了拦截器链 然后通过每个拦截器中都有intercept这个方法，这个方法中返回response然后进行返回。 这里有个流程是很有意思的就是在proceed()方法里会会返回一个Response 而 这个Response是通过intercep()这个方法并传入一个拦截器返回的，而在各个拦截器中又通过传入的拦截器调回去，这也是拦截器流程的核心机制。从而实现了拦截器链，只有所有的拦截器执行完毕后，一个网络请求的响应response 才会被返回。 内置拦截器 OkHttp中的内置连接器都基实现了通用的接口 RetryAndFollowUpInterceptor 接口重定向拦截器 这个拦截器主要是根据结果判断然后进行重试的拦截器 @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); int followUpCount = 0; Response priorResponse = null; while (true) { if (canceled) {//注意处1 streamAllocation.release(); throw new IOException(&quot;Canceled&quot;); } Response response; boolean releaseConnection = true; try {//注意处2 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; } catch (RouteException e) { // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), false, request)) { throw e.getLastConnectException(); } releaseConnection = false; continue; } catch (IOException e) { // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, requestSendStarted, request)) throw e; releaseConnection = false; continue; } finally { // We're throwing an unchecked exception. Release any resources. if (releaseConnection) { streamAllocation.streamFailed(null); streamAllocation.release(); } } // Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) { response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); } Request followUp = followUpRequest(response); if (followUp == null) { if (!forWebSocket) { streamAllocation.release(); } return response; } closeQuietly(response.body()); if (++followUpCount &gt; MAX_FOLLOW_UPS) { streamAllocation.release(); throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount); } if (followUp.body() instanceof UnrepeatableRequestBody) { streamAllocation.release(); throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code()); } if (!sameConnection(response, followUp.url())) { streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); } else if (streamAllocation.codec() != null) { throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn't close its backing stream. Bad interceptor?&quot;); } request = followUp; priorResponse = response; } } 具体分析下流程 首先会创建一个StreamAllocation对象 其实主要看while循环里面的方法，这里是一个死循环来进行尝试，首先会判断是否取消了请求，如果取消进行释放，并抛出异常，如注意处1. 然后主注意处2要进行请求，然后通过catch判断各种需要重新连接的情况，如果重新连接就通过continue直接在进行一遍循环。 当代码可以执行到 followUpRequest 方法就表示这个请求是成功的，但是服务器返回的状态码可能不是 200 ok 的情况，这时还需要对该请求进行检测，其主要就是通过返回码进行判断的，然后如果没问题就会返回respnse并结束循环。 如果没有正常返回结果的话后面会关闭请求还会做一些异常检查，如重新连接的次数是否超过了最大次数之类的。 BridgeInterceptor 请求和响应转化拦截器 这个拦截器主要负责设置内容长度，编码方式以及一些压缩等配置，主要是添加头部信息的功能。 @Override public Response intercept(Chain chain) throws IOException { Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) { MediaType contentType = body.contentType(); if (contentType != null) { requestBuilder.header(&quot;Content-Type&quot;, contentType.toString()); } long contentLength = body.contentLength(); if (contentLength != -1) { requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength)); requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); } else { requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); } } if (userRequest.header(&quot;Host&quot;) == null) { requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false)); } if (userRequest.header(&quot;Connection&quot;) == null) { requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;); } // If we add an &quot;Accept-Encoding: gzip&quot; header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) { transparentGzip = true; requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;); } List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) { requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies)); } if (userRequest.header(&quot;User-Agent&quot;) == null) { requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent()); } Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) { GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(&quot;Content-Encoding&quot;) .removeAll(&quot;Content-Length&quot;) .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(&quot;Content-Type&quot;); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); } return responseBuilder.build(); } 这里通过注意出可以看到其中一个主要的功能就是，如果刚开始我们没有配置一些请求头信息会添加一些默认的请求头信息。 这里还有一个重要功能就是 判断是否需要使用Gzip压缩功能。以及将网络请求回来的响应Response转化为永华可用的response CacheInterceptor 缓存拦截器 @Override public Response intercept(Chain chain) throws IOException { Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) { cache.trackResponse(strategy); } if (cacheCandidate != null &amp;&amp; cacheResponse == null) { closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. } // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) { return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); } // If we don't need the network, we're done. if (networkRequest == null) { return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); } Response networkResponse = null; try { networkResponse = chain.proceed(networkRequest); } finally { // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) { closeQuietly(cacheCandidate.body()); } } // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) { if (networkResponse.code() == HTTP_NOT_MODIFIED) { Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; } else { closeQuietly(cacheResponse.body()); } } Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) { if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) { // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); } if (HttpMethod.invalidatesCache(networkRequest.method())) { try { cache.remove(networkRequest); } catch (IOException ignored) { // The cache cannot be written. } } } return response; } 主要流程，先判断是否有缓存。然后如果缓存不可用会关闭，然后在会判断网络禁止的话和缓存都不可用的话会创建一个响应返回504 // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) { return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); } 如果前面的条件都不符合，会读取网络结果也就是会跳转到下一个拦截器， if (networkResponse.code() == HTTP_NOT_MODIFIED) 这里会判断如果是304的话使用缓存，还会对缓存进行比对和更新。然后并返回response。在这之前会先判断cacheResponse是否为空，如果为空则走后面的代码，会创建一个response。 ConnectInterceptor 网络连接拦截器 @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); } 这里的StreamAllocation其实是在重定向拦截器中创建，但是他传入到ConnectInterceptor中进行使用。然后会通过streamAllocation来创建httpCodec，httpCodec用来编码request和解码response。然后会通过streamAllocation.connection();来创建一个RealConnection，RealConnection主要来进行实际的网络传输。然后还是通过proceed方法传入到下一个拦截器。 CallServerInterceptor 这个拦截器是拦截器链中最后一个拦截器，是真正的发起请求和处理返回响应的拦截器。 @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) { // If there's a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100 // Continue&quot; response before transmitting the request body. If we don't get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) { httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); } if (responseBuilder == null) { // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { // If the &quot;Expect: 100-continue&quot; expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); } } httpCodec.finishRequest(); if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false); } Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); realChain.eventListener() .responseHeadersEnd(realChain.call(), response); int code = response.code(); if (forWebSocket &amp;&amp; code == 101) { // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) { streamAllocation.noNewStreams(); } if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) { throw new ProtocolException( &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength()); } return response; } 流程 这里首先会获取到之前各个拦截器中的一些参数，首先会 httpCodec.writeRequestHeaders(request);通过这个httpCodec写入请求头信息，然后会写入请求的body信息，完成写入后会调用 httpCodec.finishRequest(); 方法表示写入信息完成。 然后会读取响应信息，会先读取响应头信息，响应如果读取或者创建完成后会 通过streamAllocation.noNewStreams();这个方法进行关闭流，还会判断如果响应码是204或者205的话抛出一个异常。 其实这个拦截器链无非就是2个工作，发起请求，然后处理响应。至于中间会有一些封装请求信息判断响应信息等操作。 总结 这里拦截器的流程基本分析完了，其实主要还是看清大体流程和设计思路，具体细节的部分没有过多深入，因为这些流程设计模式才是真正要学习的重点。从源码看来 好多地方还是很值得学习的。 ","link":"http://xuanguofeng.com/post/OkHttp_No.5/"},{"title":"Android热门开源框架-OkHttp源码探究四","content":"本篇继续探究OkHttp，这次主要看OkHttp中的一个核心机制Dispatcher Dispatcher是什么？ /** * Policy on when async requests are executed. * * &lt;p&gt;Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number * of calls concurrently. */ 这是Dispatcher的注释文档，异步请求的执行策略，其实Dispatcher主要用在异步请求中，但是同步请求也会涉及。发送同步和异步请求都会在Dispatcher中管理其状态，Dispatcher维护请求状态，并且维护一个线程池。 private int maxRequests = 64; private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; /** Executes calls. Created lazily. */ private @Nullable ExecutorService executorService; /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 首先看下这几个成员变量 成员变量 含义 maxRequests 异步请求中最大的请求数量 maxRequestsPerHost 请求中支持最大的host数量 executorService 线程池 readyAsyncCalls 异步中准备请求队列 runningAsyncCalls 异步中正在运行的请求队列 runningSyncCalls 运行的同步请求队列 之前用到的几个重要方法 enqueue()方法 这个方法之前说过主要是进行异步请求。这里有一个 executorService().execute(call); 这个方法 public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService; } 这个方法主要是创建一个线程池。 finished方法 private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) { int runningCallsCount; Runnable idleCallback; synchronized (this) { if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn't in-flight!&quot;); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; } if (runningCallsCount == 0 &amp;&amp; idleCallback != null) { idleCallback.run(); } } 由于有两个队列，准备的对列要想加入运行队列 可定要在运行队列删除对应的请求，!calls.remove(call)这个方法就是将执行完的异步请求，从正在执行的队列中删除。 promoteCalls()方法主要就是将ready请求队列移到running请求队列的方法 runningCallsCount()进行重新计算请求队列和ready队列的数量 其他方法 还有些其他方法，其实也比较简单就不贴源码了，如取消所有请求的方法，获取最大请求数量、设置最大请求数量等配置方法。 总结： 其实Dispatcher的代码并不复杂，但是却在这个类里封装了关于所有的请求的管理，这要是Dispatcher的核心所在。 ","link":"http://xuanguofeng.com/post/OkHttp_No.4/"},{"title":"Android热门开源框架-OkHttp源码探究三","content":"本篇继续探究OkHttp，这次主要看异步请求流程 异步请求流程 1.创建OkHttpClient和Request对象 2.将Request封装成Call对象 3.调用Call的enqueue()发送同步请求 4.在callback中处理成功和失败的请款 源码执行流程 流程分析 同步主要通过call.enqueue方法去执行，这个方法主要在RealCall中 @Override public void enqueue(Callback responseCallback) { synchronized (this) { if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; } captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); } 1、其实这段代码的流程基本和同步的一样 只不过是最后要执行enqueue方法，而同步的是通过 getResponseWithInterceptorChain();直接获取result了。当然异步也是执行getResponseWithInterceptorChain();获取result。只不过在获取result之前做了一些异步操作。 2、获取通过enqueue()方法并传入了一个new AsyncCall(responseCallback)进行异步操作，其实这个AsyncCall是一个Runnable。这时大概就明白了。 3、先看下Dispatcher里的这个enqueue方法。这个Dispatcher是一个调度器核心类，下一节单独整理。 synchronized void enqueue(AsyncCall call) { if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) { runningAsyncCalls.add(call); executorService().execute(call); } else { readyAsyncCalls.add(call); } } 这里其实也很简，由于是异步，有一个异步运行队列，和一个准备队列。这里会进行条件判断，就是首先判断目前请求队列里的请求数量是不是小于最大的数量，最大值为64。并且call对应的host数目不应超过maxRequestsPerHost，maxRequestsPerHost的值是5。 如果满足条件就添加到运行的队列中，如果不满足就添加到准备队列中。然后通过线程池实例executorService进行执行。 AsyncCall分析 上文提到AsyncCall其实是NamedRunnable的子类 而 NamedRunnable又实现Runnable接口。 /** * Runnable implementation which always sets its thread name. */ public abstract class NamedRunnable implements Runnable { protected final String name; public NamedRunnable(String format, Object... args) { this.name = Util.format(format, args); } @Override public final void run() { String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try { execute(); } finally { Thread.currentThread().setName(oldName); } } protected abstract void execute(); } 这里看到其实在run方法里执行了execute这个方法，所以我们重点分析NamedRunnable实现类的的execute方法。 final class AsyncCall extends NamedRunnable { private final Callback responseCallback; AsyncCall(Callback responseCallback) { super(&quot;OkHttp %s&quot;, redactedUrl()); this.responseCallback = responseCallback; } String host() { return originalRequest.url().host(); } Request request() { return originalRequest; } RealCall get() { return RealCall.this; } @Override protected void execute() { boolean signalledCallback = false; try { Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) { signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); } else { signalledCallback = true; responseCallback.onResponse(RealCall.this, response); } } catch (IOException e) { if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); } else { eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); } } finally { client.dispatcher().finished(this); } } } 其实execute的流程和同步的也基本差不多了 最主要还是通过getResponseWithInterceptorChain（）方法返回Response，getResponseWithInterceptorChain这个方法后面会单独详细说明。 然后主要流程就是先通过国拦截器判断是否取消请求，如果取消的话执行onFailure返回，否则返回onResponse并传入response。 然后就是异常处理也返回onFailure。 最后要执行finished。 总结： 其实同步和异步的主要区别在于线程池的使用，然后其他流程也是通过OkHttp中的拦截器链进行返回响应。在这里可以体会下这种设计的巧妙之处。 ","link":"http://xuanguofeng.com/post/OkHttp_No.3/"},{"title":"Android热门开源框架-OkHttp源码探究二","content":"本篇继续探究OkHttp，这次主要看同步请求流程 同步请求流程 使用流程 1.创建OkHttpClient和Request对象 2.将Request封装成Call对象 3.调用Call的execute()发送同步请求 源码执行流程 同步主要通过call.execute方法去执行，这个方法主要在RealCall中 @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; } //见 解释处1 captureCallStackTrace(); eventListener.callStart(this);//见解释处2 try { client.dispatcher().executed(this);//见解释处3 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; } catch (IOException e) { eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } 这段代码的步骤 1.首先通过executed判断这个方法是否被执行，执行过的话就抛出异常，没有执行的话就设置executed为true,防止下次执行，这么看来每个call只能被执行一次，如果想要一个完全一样的call,可以进行clone方法克隆。 2.通过eventListener.callStart(this);方法开启了一个事件监听器，这个监听器的介绍也有，主要监控HTTP的调用的数量、大小和持续时间等，这个监听器，在异步请求方法中也会开启。 3.client.dispatcher().executed(this);这句话其实是将请求添加到同步请求队列中] /** Used by {@code Call#execute} to signal it is in-flight. */ synchronized void executed(RealCall call) { runningSyncCalls.add(call); } 这个 runningSyncCalls其实就是一个同步请求队列集合。dispatcher是OkHttpClient.Builder的成员，后面会单独分析。 4.调用 getResponseWithInterceptorChain这个方法来获取response。这个方法可以先浏览下 后面会进行分析。 Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); } 其实主要就是通过一层一层的拦截器操作，比如重试拦截器，缓存拦截器等，这也是OkHttp的核心思想之一，通过一系列拦截器可以进行各种功能的扩展和实现。后面会单独分析。 5.如果result不为null将结果返回，如果有异常的话 执行监听的failed方法。最后无论如何都要通过dispatcher的finished方法通知dispatcher执行完毕。 注意：同步发送请求后，就会进入阻塞状态直到收到请求， 总结 这样，其实同步请求流程的表面源码基本已经分析完毕了，但是在这段代码后还隐藏着一些其他的机制，我们后面分析异步的时候会分析到。 ","link":"http://xuanguofeng.com/post/OkHttp_No.2/"},{"title":"Android热门开源框架-Okhttp源码探究一","content":"OkHttp是目前很流行的网络请求框架。源码也设计很优秀的思想。有必要去探究一下源码。 由于篇幅较长，分为五篇文章。本篇文章将讨论OkHttp的执行流程分析 文章目录 一、OkHttp执行流程分析 二、同步请求流程分析 三、异步请求流程分析 四、任务调度核心dispatcher 五、OkHttp中五大拦截器源码与功能分析 OkHttp执行流程分析 流程图 流程分析 1、创建OkHttpClient OkHttpClient是一个通过build模式去构建的。 public Builder() { dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; } 然后通过build的build方法构建 public OkHttpClient build() { return new OkHttpClient(this); } 这里主要是通过build设计模式配置一些常用的参数信息，如超时时间等。 2、创建Request public Builder() { this.method = &quot;GET&quot;; this.headers = new Headers.Builder(); } Builder(Request request) { this.url = request.url; this.method = request.method; this.body = request.body; this.tag = request.tag; this.headers = request.headers.newBuilder(); } Request也是通过build模式配置一些请求信息等，如url,请求方法，请求体，请求头等。 3、创建Call Call call = client.newCall(request); 主要是通过client.newCall然后传入一个request来进行创建。 @Override public Call newCall(Request request) { return RealCall.newRealCall(this, request, false); } 这里其实是创建了一个RealCall，RealCall也是OkHttp框架主要流程的一部分，主要是链接request和Response的桥梁，通过call进行同步和异步方法的执行。在同步和异步的执行方法里会返回response。例如： @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; } captureCallStackTrace(); eventListener.callStart(this); try { client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; } catch (IOException e) { eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } 4、通过Call执行同步或者异步请求，获取response Response response = call.execute(); System.out.println(response.body().string()); 上面已经说过通过call的execute可以进行同步请求，然后获取response，这个response就是我们想要的返回的信息。 也可以通过call.enqueue方法传入也一个监听器，进行异步请求。 call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { //返回失败的情况 } @Override public void onResponse(Call call, Response response) throws IOException { //调用成功的情况 } }); 5、完整的get请求，和post请求示例 get OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string(); } post public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;); OkHttpClient client = new OkHttpClient(); String post(String url, String json) throws IOException { RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); return response.body().string(); } 6、总结 这篇只是简单分析OkHttp的使用流程，其实还有一部分核心的流程是在源码中体现的比如dispatcher调度器的使用流程，与拦截器的核心功能等，这一部分将在后面的总结中进行单独分析。 ","link":"http://xuanguofeng.com/post/OkHttp_No.1/"},{"title":"Android优化-绘制优化","content":"Android系统显示原理 Android应用程序把经过测量，绘制，布局的surface缓存数据，通过SufraceFilnger把数据渲染到显示屏幕上通过Android的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务他通过刷新机制把数据更新到屏幕。 应用层 view的绘制有三个核心步骤，通过Measure和Layout来确定当前需要绘制的View所在的大小和位置，通过绘制（Draw）到surface,递归方式获取View的大小和位置，并以深度作为优先级，层级越深，元素越多，耗时也就越长。 系统层 系统层主要是将要显示的数据渲染到屏幕上，CPU主要负责数据计算工作，GPU负责渲染。API不允许CPU和GPU直接通信， 所以通过中间的一个图形驱动器来连接这两部分。图形驱动维护了一个队列，cpu把 diplay list添加到队列中，GPU从这个队列取出数据并进行绘制，最终在屏幕显示出来。 Android页面卡顿的原因 界面绘制方面 主要原因是绘制的层级深、页面复杂、刷新不合理、由于这些原因导致卡顿的场景更多出现在UI和启动后的初始界面以及跳转到页面的绘制上。 数据处理方面 原因是数据的处理量太大，一般分为三种情况 数据处理在UI线程 数据处理占用CPU搞导致主线程拿不到时间片 内存增加导致GC频繁 优化方法 布局优化 merge viewStub https://xuanguofeng.github.io/2016/06/10/Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96merge%E3%80%81ViewStub%E7%9A%84%E7%94%A8%E6%B3%95/ ReativeLayout和LinearLayout ReativeLayout存在性能低的问题，原因是ReativeLayout会对子view做两次测量，如果LinearLayout中有weight属性，也需要进行两次测量，因为没有更多的依赖关系，所有仍然会比ReativeLayout效率高，但是如果LinearyLayout嵌套过多，层次过深灰增加内存消耗，甚至引起溢出等问题。在布局上RelativeLayout不如LinearLayout快。如果嵌套过多的话要选用RelativeLayout，如果优化掉两层仅仅增加一次测量，还是非常值得的。 总结： 尽量使用​​RelativeLayout和LinearLayout 布局层级相同情况下，使用​LinearLayout LinearLayout如果会嵌套过多使用​RelativeLayout 避免过度绘制 过度重绘是指在屏幕上的某个像素在同一帧的时间内被绘制了多次。 例如： LIstView中把ImageView的Background设置为Transparent,只有当图像没有获取到时，才设置对应Background占位图，这样可以避免给Avatar设置背景图而导致的过度渲染。 避免过度绘制的一些方法： 1.移除XML中非必须的背景 2.移除window默认的背景 3.按需显示站位背景图片。 4.自定义view优化：可以通过canvas.clipRect()来帮助系统识别那些可见的区域。​​S this.getWindow().setBackgroundDrawable(null);​ 页面刷新 要合理的控制页面的刷新机制，尽量减少刷新次数和缩小刷新区域。 关于动画 Android提供了3种动画机制，其中帧动画是最消耗内存的，效果也最差，所以一般不推荐使用，补间动画也会导致view重绘频繁，而且事件也不会跟随动画，所以推荐基于性能考虑推荐使用属性动画，属性动画递归的次数要明显小于补间动画，也没有补间动画事件的问题。 使用硬件加速 Android3.0后引入了硬件加速概念，用来提高渲染速度，并达到更顺畅的效果 启动优化 启动优化主要就是在APP的启动过程中做尽量少的事情，启动主要完成三件事，UI布局、绘制和数据准备，启动速度就的优化就是要优化这个三个过程。 性能分析工具 Profile GPU Rendering 这个工具在开发者选项中可以打开，主要功能： 图形检测工具，能实时反映当前绘制的耗时。 横轴表示时间，纵轴表示每一帧的耗时。 随之时间推移，从左到右的刷新呈现。 提供了一个标准的耗时。 TraceView TraceView是Android SDK自带工具，用来分析函数调用过程，可以对Android的应用程序以及Framework层的代码进行性能分析。 Hierarchy Viewer 布局优化工具 Hierarchy Viewer工具提供了一个可视化界面显示布局的层次结构，用来检测Layout嵌套及绘制时间，以可视化的布局角度直观获取Layout布局设计和各种属性信息，开发者在台欧式和布局UI界面可以很方便的使用。 过度绘制检测工具 开发者选项中打开 show GPU Overdraw选项 描述方式： 无色：没有过度绘制，每个像素绘制了1次。 蓝色：每个像素多绘制了1次。大片蓝色还是可以接受的如果整个窗口是蓝色的，可以尝试优化减少一层绘制。 绿色：每个像素多绘制了2次。 淡红：每个像素多绘制了3次，一般来说这个区域不超过屏幕的1/4是可以接受的。 深红：每个像素多绘制4次或者更多。严重影响性能，需要优化，避免深红色区域。 ","link":"http://xuanguofeng.com/post/Android优化-绘制优化/"},{"title":"重温java基础-反射机制","content":"反射是什么？ 在运行状态中，获取一个类的所有属性和方法。这种动态获取信息以及调用对象的方法的功能。 使用反射机制的一些框架？ Retrofit中的注解功能、EventBus，动态生成框架 Gson。 使用反射技术查看类信息 获取Class对象的三种方法 使用Object.getClass方法 如果我们能知道一个对象，可以通过调用这个对象的getClass方法获得一个Class对象。 例如： Person person = new Person(); Class&lt;? extends Person&gt; aClass = person.getClass(); System.out.println(aClass.getName()); 这时候就会打印这个对象的全包名，aClass中还有其他信息。 使用.class方法 Class&lt;? extends Person&gt; aClass = Person.class; System.out.println(aClass.getName()); System.out.println(int.class); 如果没有获取某个类的对象，无法使用getClass方法，可以直接在类名加上.class来获取，这种方式可以用于基本数据类型。 使用Class.forName()方法 这个方法要使用一个类的完整路径，就可以使用Class.forName(&quot;类的完整路径&quot;)来得到相应的Class。 try { Class mclass1 = Class.forName(&quot;main.fanshe.Person&quot;); System.out.println(mclass1.getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); } 注意：使用Class的newInstance()方法来创建对应类的实例，需要有默认的构造器，执行newInstance()方法实际上市利用默认构造器来创建该类的实例。 Class mclass1 = Class.forName(&quot;main.fanshe.Person&quot;); Object o = mclass1.newInstance(); 通过反射获取成员变量 常用获取成员属性的方法 Field[] declaredFields = mclass1.getDeclaredFields();//获取Class对象的所有属性 Field[] fields = mclass1.getFields();//获取class对象的public属性 Field ageField = mclass1.getDeclaredField(&quot;age&quot;);//获取class指定属性 Field desFiedl = mclass1.getField(&quot;name&quot;);//获取class指定的public属性 如果获取到属性可以用过set方法进行修改例如： Field ageField = mclass1.getDeclaredField(&quot;age&quot;);//获取class指定属性 ageField.setInt(o,22); 如果这个属性是用private修饰的话,这样写的话代码会报错 java.lang.IllegalAccessException: Class main.fanshe.Main can not access a member of class main.fanshe.Person with modifiers &quot;private&quot; at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102) at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296) at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288) at java.lang.reflect.Field.setInt(Field.java:946) at main.fanshe.Main.main(Main.java:50) 这时我们要添加 ageField.setAccessible(true);这个方法来声明这个变量是可以访问的就没问题了，但是使用这个方法也可能会导致些其他问题，例如 在运行时虽然你通过反射修改了变量 a 的值，但其他部分可能还在使用原来的值。 通过反射获取成员方法 Method[] methods = mclass1.getDeclaredMethods();//获取class对象的所有声明方法 Method[] allMethods = mclass1.getMethods();//获取class对象的所有public声明方法 Method method = mclass1.getMethod(&quot;getAge&quot;);//根据方法名返回方法 Method method2 = mclass1.getMethod(&quot;getAge&quot;,String.class);//根据带指定形参列表的public方法 System.out.println(method.toString()); 可以通过method.invoke(o);这个方法调用反射到的方法。 总结 反射还有好多其他方法，可以通过查询API获知，例如获取构造方法等，功能貌似还是比较强大的，但是反射的一些操作可能会引起性能消耗，例如修改某个成员变量的时候，需要引发验证访问权限等额外操作等。所以使用反射的时候也许要考虑下性能方面的问题。 本篇文章参考：http://blog.csdn.net/u011240877/article/details/54604212 ","link":"http://xuanguofeng.com/post/重温java基础-反射机制/"},{"title":"Android优化-内存优化","content":"Java对象的生命周期经历7个阶段，分别是创建阶段、应用阶段、不可见阶段、不可达阶段、收集阶段、终结阶段、对象控件重新分配阶段。 一、Android内存管理机制 1、Java对象的生命周期 Java对象的生命周期经历7个阶段，分别是创建阶段、应用阶段、不可见阶段、不可达阶段、收集阶段、终结阶段、对象控件重新分配阶段。 2、内存回收机制 内存的三个区域 内存会有三个区域，Yong Generation(年轻代)、Old Generation(年老代)、permanent Generation（持久代）。 其中年轻代里面又分为三个区，eden、S0、S1。 内存的处理过程： 1.对象创建后在Eden区域， 2.执行GC时，如果对象仍然存货，则复制到S0区。 3.当S0区满时，改区域存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换。 4.当第三部达到一定次数后，存活对象将被复制到Old Generation。 5.当这个对象在Old Generation区域挺溜的时间达到一定程度时，它会被移动到Old Generation，最后积累一定时间再移动到Permaent Generation区域，Permaent Generation区域也存放一些静态文件。 GC回收的一些算法 Copying算法：扫描出存活的对象，并复制到一块新的完全未使用的控件中，对应于Young Generation，就是在Eden、FromSpace或ToSpace之间copy。 标记算法：扫描出存活对象，然后再回收未标记的对象，回收后对空出的空间要么合并，要么标记出来便于下次分配，以减少内存碎片带来的损耗。年老代对象存活时间较长较稳定，使用标记算法回收。 GC类型 1.kGcCauseForAlloc：在分配内存时内存不够情况下引起的GC,这种情况下GC会stop World。Stop World 是由于并发GC时，其他线程都会停止。 2.kGcCauseBackground：当内存达到一定阈值的时候引发GC，这个时候是一个后台GC,不会引起Stop World。 3.kGcCauseExplicit：显示调用时进行的GC，如果ART打开了这个选项，在system.gc时会进行GC。 其他GC注意事项 1.尽量不去显式调用 system.gc() 减少不必要的系统开销，影响应用的流畅度。 2.尽量减少内存泄露，避免OOM。 二、Android内存泄露 1、什么是内存泄露？ java对象有自己的生命周期，当这个对象不需要再使用时，应该完整地走完生命周期，但因为某些原因，对象虽然已经不再使用，仍然在内存中并没有结束整个生命周期，这就意味着这个对象已经泄露了。 GC会选择一些还存活的对象作为内存遍历的根节点 GC Roots,通过对GC Roots的可达性来判断是否需要回收。 Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些存活的对象作为内存便利的跟节点GC Roots,通过判断GC Roots的可达性来判断是否需要回收，如上图其中 1 2 3 4直接或间接被GC Roots引用链相连，这类对象被认为还需要使用的对象，就不会被回收。5 6 7将会被回收。到那时这里如果Object4 如果不需要使用的话这时候也不会被回收，就属于内存泄露。 2、常见内存泄露场景以及注意事项 ~ 资源型对象未关闭 ~ 注册对象未注销 ~ 类的静态变量持有大数据对象 如bitmap ~ 费静态内部类的静态实例 ~ Handler临时性内存泄露 ~ 容器中的对象没有清理造成的内存泄露 3、内存泄露分析工具 leakcanary 三、常见注意事项避免内存消耗过多 1、AutoBoxing自动装箱过程 Integer num=0; for(int i=0;i&lt;100;i++){ num+=i; ​​}​​ 这段代码每次循环，虚拟机都必须创建一个新的整数对象，并把它加到其他整数对象前面，创建一个新的整数对象，意味着要消耗更多性能。int只有4字节，而Integer对象有16字节。 2、内容复用 1、有效利用系统自带资源。 2、视图复用，如ViewHolder。 3、对象池。 4、Bitmap对象复用。 3、使用最优的数据类型 1、当对象的数目在1000以内且特别多访问而删除和插入不高的时候尽量用ArrayMap替代HashMap。 2、枚举的最大优点是安全、易读，但是内存消耗是定义常量的三倍以上。可以使用注解方式来检查安全。 3、使用IntDef和StringDef检查类型安全。 4、LruCache建议使用这个缓存机制，但是既不能分配太大，也不能分配太小。 4、图片的内存优化 设置位图规格，使用inSampleSize实现位图缩放和压缩。使用缓存机制等。 四、内存分析工具 1、Memory Monitor 这个是一个我们开发过程中很常用的内存、CPU、网络的分析工具。 界面很直观，左上角有运行的机型和项目包名，然后最直观的动态图，分别是CPU、Memory、NetWork。点进去可以进入的Memory。 这里可以清晰的看到颜色对应区域占用的内存大小。 通过这两张图 内存的大部分信息都能查阅到。我们在操作APP加载图片等操作时候能看到内存上升、和下降，如果操作APP后发现内存不会下降可能就是我们有些对象没有及时释放，也有可能导致内存泄露。 还有对应的模拟GC，查看时间段具体内存信息以及一段时间的内存追踪等工具可以使用。可以定位到具体的代码行。如下图： 这里有一个Shallow size这个属性的概念： Shallow size就是对象本身占用内存的大小，不包含其引用的对象。常规对象（非数组）的Shallow size有其成员变量的数量和类型决定。数组的shallow size有数组元素的类型（对象类型、基本类型）和数组长度决定。 2、Heap Viewrer 如果是Android Studio的话通过Tools-&gt;Android-&gt;Android Device Monitor找到这个工具。 进入后选择运行APP的包名然后点击update Heap按钮，这时候会在每次gc时展示数据信息，也可以在后面手动GC，如果在操作页面这时候可能会发现小卡顿，因为在GC时，可能导致其他线程停止工作，这时可以清晰看到表中内存信息： 头部总览视图： 标题 含义 Heap Size 堆栈分配给APP的内存大小。 Allocated 已分配使用的内存大小。 Free 空闲的内存大小。 %Used Allocated/Heap Size 的使用率。 #Object 对象数量 下面详情视图： 标题 含义 free 空闲的对象 data object 数据对象，Java类类型对象，是最主要的观察对象。 class object java类类型的引用对象。 1-byte array(byte[],boolean[]) 一字节的数组对象。 2-byte array(short[],char[]) 两字节的数组对象。 4-byte array(object[],int[],float[]) 4字节的数组对象。 8-byte array(long[],double[]) 8字节的数组对象。 non-java object 非Java对象。 每个类型的数据值对应： 标题 含义 Count 数量 Total Size 总共占用的内存的大小 Smallest 将对象占用内存从小到大排列，排在第一个对象占用内存大小 Largest 将对象占用内存从小到大排列，排在最后一个对象占用的内存大小。 Median 将对象占用内存从小到大排列，排在总监的对象占用的内存大小。 Average 平均值 ","link":"http://xuanguofeng.com/post/Android优化-内存优化/"},{"title":"RxJava简单使用","content":"一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库，是通过使用观察者模式。 其实个人认为主要看其中的几个关键词就可以了有：异步，事件，观察者模式，看到这几个关键词其实大概对这个东西也就有了基本的印象。 RxJava最直观的使用总结 一、RxJava是什么？ RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences. 一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库，是通过使用观察者模式。 其实个人认为主要看其中的几个关键词就可以了有：异步，事件，观察者模式，看到这几个关键词其实大概对这个东西也就有了基本的印象。 二、RxJava相关资料 Github地址 https://github.com/ReactiveX/RxJava 文档地址 https://www.gitbook.com/book/mcxiaoke/rxdocs/details 优秀博文 http://gank.io/post/560e15be2dca930e00da1083#toc_1 三、观察者模式 其实观察者模式很简单。一个例子： 好多网站的文章是支持用户订阅的，如果有更新就会发邮件给用户，这个模式就可以用观察者模式来形容。 如 网站被看做被观察者，用户被看做观察者，然后被观察者将观察者订阅（这里有点网站订阅用户的意思，虽然字面意思是这样，但是我们理解可以按照正常思维理解，是让观察者和被观察者关联起来），当有更新的时候被观察者通知观察者。从而产生观察者中观看文章的事件。 四、RxJava使用 一、基本使用 在RxJava中有三个基本的概念。Observable、Observer、subscribe()。 这三个概念从字面意义也基本能猜测。 Observable:代表着被观察者，也就是上文中网站。 Observer:代表着观察者，也就是上文中的用户。 subscribe:这是一个方法，也就是订阅。 Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; observableEmitter) throws Exception { observableEmitter.onNext(&quot;1&quot;); } }); Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onSubscribe(@NonNull Disposable disposable) { Log.e(TAG, &quot;onSubscribe&quot;); } @Override public void onNext(@NonNull String s) { Log.e(TAG, &quot;onNext---&gt;&quot;+s); } @Override public void onError(@NonNull Throwable throwable) { Log.e(TAG, &quot;onError&quot;); } @Override public void onComplete() { Log.e(TAG, &quot;onComplete&quot;); } }; observable.subscribe(observer); 运行结果如下： 10-23 02:38:52.525 3820-3820/com.xuanguofeng.rxjava E/MainActivity----&gt;: onSubscribe 10-23 02:38:52.525 3820-3820/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext---&gt;1 大概流程就是这样 被观察者(网站)可以通过onNext()方法告诉观察者(用户)，新闻给你发过去了你看下吧，然后观察者(用户)也通过onNext方法里面的参数进行“看新闻”。 这里还有另外几个方法 onSubscribe()，onNext(),onError()，onComplete()我们分别试试 先看onComplete() Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; observableEmitter) throws Exception { observableEmitter.onNext(&quot;1&quot;); observableEmitter.onNext(&quot;2&quot;); observableEmitter.onNext(&quot;3&quot;); observableEmitter.onComplete(); observableEmitter.onNext(&quot;4&quot;); observableEmitter.onNext(&quot;5&quot;); } }); 把被观察者里的时间修改一下看下观察者里的结果 10-23 03:09:58.640 4281-4281/? E/MainActivity----&gt;: onSubscribe 10-23 03:09:58.641 4281-4281/? E/MainActivity----&gt;: onNext---&gt;1 10-23 03:09:58.641 4281-4281/? E/MainActivity----&gt;: onNext---&gt;2 10-23 03:09:58.641 4281-4281/? E/MainActivity----&gt;: onNext---&gt;3 10-23 03:09:58.641 4281-4281/? E/MainActivity----&gt;: onComplete 会发现后面的4 5事件不见了 这就是代表着如果调用了这个方法其实事件还是在继续发送，只是我们的观察者里面不接收了。 这个流程和onError()是一样的当调用onError()的时候,onError()也是被观察者可以继续发事件，但是后面不会再接收。 这两个事件onComplete和onError可以不发送。 onComplete和onError这两个方法唯一并且互斥，就是不能多发，也不能同时发。 onSubscribe这个方可以看到总是在第一个调用，即使没有任何事件发送。 当然也可以写成这样，就是RxJava中被广泛流传的链式调用。 Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; observableEmitter) throws Exception { observableEmitter.onNext(&quot;1&quot;); observableEmitter.onNext(&quot;2&quot;); observableEmitter.onNext(&quot;3&quot;); observableEmitter.onComplete(); observableEmitter.onNext(&quot;4&quot;); observableEmitter.onNext(&quot;5&quot;); } }).subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(@NonNull Disposable disposable) { Log.e(TAG, &quot;onSubscribe&quot;); } @Override public void onNext(@NonNull String s) { Log.e(TAG, &quot;onNext---&gt;&quot;+s); } @Override public void onError(@NonNull Throwable throwable) { Log.e(TAG, &quot;onError&quot;); } @Override public void onComplete() { Log.e(TAG, &quot;onComplete&quot;); } }); 二、异步 RxJava在介绍的时候有一个关键词是异步，那么就要在考虑一个问题，RxJava如果进行不同线程的操作呢？ 其实上面所做的操作，都是在当前线程完成，在当前线程发送事件，在当前线程处理事件，怎么证明他们是在同一个线程呢?分别在发送和处理的事件里增加一个获取线程id的log。打印如下： 10-23 03:40:02.965 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onSubscribe 10-23 03:40:02.965 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onSubscribe-&gt;线程id-----&gt;1 10-23 03:40:02.965 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext---&gt;1 10-23 03:40:02.965 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext-&gt;线程id-----&gt;1 10-23 03:40:02.965 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: subscribe-&gt;线程id---&gt;1 无论是发送还是接收都在id为1的线程，也就是ui线程。 Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; observableEmitter) throws Exception { observableEmitter.onNext(&quot;1&quot;); observableEmitter.onNext(&quot;2&quot;); observableEmitter.onNext(&quot;3&quot;); Log.e(TAG, &quot;subscribe-&gt;线程id---&gt;&quot; + Thread.currentThread().getId()); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(@NonNull Disposable disposable) { Log.e(TAG, &quot;onSubscribe&quot;); Log.e(TAG, &quot;onSubscribe-&gt;线程id-----&gt;&quot; + Thread.currentThread().getId()); } @Override public void onNext(@NonNull String s) { Log.e(TAG, &quot;onNext---&gt;&quot; + s); Log.e(TAG, &quot;onNext-&gt;线程id-----&gt;&quot; + Thread.currentThread().getId()); } @Override public void onError(@NonNull Throwable throwable) { Log.e(TAG, &quot;onError&quot;); } @Override public void onComplete() { Log.e(TAG, &quot;onComplete&quot;); } }); 打印结果 10-23 03:43:26.774 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onSubscribe 10-23 03:43:26.774 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onSubscribe-&gt;线程id-----&gt;1 10-23 03:43:26.775 10588-14670/com.xuanguofeng.rxjava E/MainActivity----&gt;: subscribe-&gt;线程id---&gt;248 10-23 03:43:26.846 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext---&gt;1 10-23 03:43:26.846 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext-&gt;线程id-----&gt;1 10-23 03:43:26.846 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext---&gt;2 10-23 03:43:26.846 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext-&gt;线程id-----&gt;1 10-23 03:43:26.846 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext---&gt;3 10-23 03:43:26.846 10588-10588/com.xuanguofeng.rxjava E/MainActivity----&gt;: onNext-&gt;线程id-----&gt;1 可以看到 发送的线程id是248，而处理事件的线程是1。仔细看下代码变化在于 .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) 链式调用了这两个方法，也很直观一个是在什么线程发送，另一个是在什么线程处理，这里新建了一个线程发送，然后在UI线程进行接收处理。 RxJava中有四个线程可以让我们选择： Schedulers.io():IO线程，主要用于网络读写 Schedulers.computation()：代表CPU计算密集型的操作, 例如需要大量计算的操作 Schedulers.newThread()：这个当然是代表创建一个新的常规线程 AndroidSchedulers.mainThread()：这个代表Android中的UI线程，可以在这里更新页面操作 ","link":"http://xuanguofeng.com/post/RxJava简单使用/"},{"title":"Android动画的分类与使用总结（参照官方api）","content":"为什么使用动画自从Android5.0以后，Google宣布了Material Design的设计语言，也增加了很多动画效果，使得app看起来更自然美观，交互体验更好。在我们的app里如果适当的使用动画的话，会给app带来更棒的交互体验，当然如果动画用的不合适或者滥用的话，也会带来更糟的体验。所以我们在了解动画机制的情况下适当的使用动画才是锦上添花。 这里提供Google对Material Design对介绍地址：https://material.io/guidelines/motion/material-motion.html# Android中动画的分类 Android framework 提供了2中动画框架：属性动画和视图动画。两种动画框架都是可行的，但一般来说属性动画是首选的方法，因为它使用起来更灵活也提供了更多的特性，除了这两种动画框架，也可以使用帧动画（Drawable animation），帧动画允许加载并展示一张一张的可描绘资源组成动画。 Property Animation（属性动画） 属性动画是在Android3.0之后提供的动画，可以对一个对象的属性进行操作，从而达到动画的效果，包括没有被渲染到屏幕上的，该系统是可扩展的，让您可以将定制类型的属性进行动画化。 View Animation（视图动画） 视图动画是较老的系统，只能用于视图，设置和提供足够的能力来满足许多应用程序的需求是相对容易的 Drawable Animation（帧动画） 可绘制的动画需要一个接一个地显示可绘制的资源，就像胶卷一样。如果您希望用可绘制的资源来表示更容易表示的动画，比如位图的进展，那么这种动画方法是非常有用的。 视图动画与属性动画的区别（How Property Animation Differs from View Animation） 只能支持简单的缩放、平移、旋转、透明度基本的动画，且有一定的局限性。 视图动画系统的另一个缺点是它只修改了视图被绘制的地方，而不是实际的视图本身。例如对一个imageview添加事件后，平移那么事件还是会在之前的位置。 属性动画将不存在这些限制，您可以对任何对象(视图和非视图)的任何属性进行动画，并且对象本身实际上是被修改的。视图动画的使用比较简单。 属性动画的使用 ObjectAnimator ObjectAnimator是属性动画框架中最重要的实行类，创建一个ObjectAnimator只需要通过静态工厂类直接返回一个ObjectAnimator对象即可。参数包含一个对象和对象的属性名字，但是这个属性必须有get和set函数，内部会通过反射机制来调用set函数修改对象的属性值。 例如：一个图片平移的动画 ObjectAnimator anim = ObjectAnimator .ofFloat(view, &quot;translationX&quot;, 300) .setDuration(500); anim.start(); 通过这段代码就能使得这个view进行平移动画。 ofFloat源码： public static &lt;T&gt; ObjectAnimator ofArgb(T target, Property&lt;T, Integer&gt; property, int... values) { ObjectAnimator animator = ofInt(target, property, values); animator.setEvaluator(ArgbEvaluator.getInstance()); return animator; } 第一个参数是我们要操纵的view，第二个参数是要操纵的属性。 最后一个是一个可变数组参数，需要穿进去该属性变化的一个取值过程，这里设置了一个参数，即变化到300。 常用的属性： 属性名称 属性描述 translationX和translationY 这两个属性作为一种增量来控制着view对象从它布局容器的左上角坐标偏移的位置 ratation,rotationX,rotationY 这三个属性控制view对象围绕支点进行2D和3D旋转 scaleX,scaleY 这两个属性控制着view对象围绕它的指点进行2D缩放 pivotX,pivotY 这两个属性控制着view对象的支点位置，围绕这个支点进行旋转和缩放变换处理。默认情况下，该质点的位置就是view对象的中心点 x,y 这两个简单实用的属性，它描述了view对象在它的容器中的最终位置，它是最初的组奥上交坐标和translationX，translationY值的累积和。 alpha 它表示view对象的alpha透明度。默认值是1（不透明），0代表完全透明（不可见）。 ValueAnimator ValueAnimator类允许您通过指定一组int、float或颜色值来激活动画的持续时间，从而监听数值的变化完成动画的变换。 ValueAnimator animation = ValueAnimator.ofFloat(0, 100); animation.setTarget(view); animation.setDuration(1000); animation.start(); animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { Float value = animation.getAnimatedFraction(); Log.e(&quot;tag&quot;, String.valueOf(value)); } }); 动画事件的监听 objectAnimator可以监听动画从开始到结束的四个过程。 anim.addListener(new Animator.AnimatorListener() { @Override public void onAnimationStart(Animator animation) { } @Override public void onAnimationEnd(Animator animation) { } @Override public void onAnimationCancel(Animator animation) { } @Override public void onAnimationRepeat(Animator animation) { } }); 不过大部分时候我们需要关心动画结束时，所以可以直接这样： anim.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); } }); AnimatorSet AnimatorSet可以实现多种动画的展示。 AnimatorSet set=new AnimatorSet(); set.setDuration(1000); set.playTogether(anim1,anim2); set.start(); 除了set.playTogether（）方法，还有playSequentially(),set.play().with(),set.play().before(),set.play().after()等方法来控制多个动画的协同工作方式，从而控制顺序。 视图动画的使用 在3.0之前，视图动画是被广泛应用，但3.0后属性动画的出现，使得视图动画的缺点也就被放大了。主要一个缺点就是当视图移动后，其响应事件的位置还依然在动画前的地方，所以视图动画只能做普通的动画展示效果，避免交互的发生。 主要提供了AlphaAnimation,RotateAnimation,TranslateAnimation,ScaleAnimation四种动画方式，也提供了AnimationSet动画集合，混合使用多种动画。 RotateAnimation（旋转动画） RotateAnimation rotateAnimation=new RotateAnimation(0,360,100,100); rotateAnimation.setDuration(1000); view.startAnimation(rotateAnimation); 参数分别为旋转的起始角度和旋转中心点的坐标。 TranslateAnimation（位移动画） ScaleAnimation（缩放动画） 总结：其实每种动画的的使用方式基本相同，无非就是一些参数的特性不同。 ","link":"http://xuanguofeng.com/post/Android动画的分类与使用总结（参照官方api）/"},{"title":"Java常用排序算法冒泡排序与选择排序总结","content":"排序算法有好多种，也在特殊的场景中，我们经常需要对我们的数据进行排序，这里对经典的排序做一个记录整理。 一冒泡排序 原理分析 冒泡排序其实就是对一组数以类似冒泡对形式，进行从大到小或者从小到大的排序，那么什么是冒泡呢？ 其实也简单，比如有一组数字：3，9，6，2 以上图只比较了第一轮，会冒出一个较大大，依此类推进行比较。 以此比较两个数字，将较较小的数字一个一个冒上来，将相反的较大的数字往下沉，然后内层循环每一轮比较就会冒出来一个最大数字，这样有2层循环即可，外层循环完后，所有的数字就冒完了。 代码实现（java） public class MPTest { public static void main(String[] args) { int [] numbers={3,9,6,2}; int temp=0; for(int i=0;i&lt;numbers.length-1;i++){ for(int j=0;j&lt;numbers.length-1-i;j++){／/内层循环一次冒泡出一个比较小的数上来 if(numbers[j]&gt;numbers[j+1]){//如果第一个数字比第二个大则交换位置 temp=numbers[j]; numbers[j]=numbers[j+1]; numbers[j+1]=temp; } } } for(int i=0;i&lt;numbers.length;i++){ System.out.println(&quot;第&quot;+i+&quot;个数字是：&quot;+numbers[i]); } } } 输出结果是： 第0个数字是：2 第1个数字是：3 第2个数字是：6 第3个数字是：9 二选择排序 原理分析 选择排序其实其实思路也是比较简单的，也是2层循环。 主要思路是记录一个最小值，然后内层循环如果有比它小的就跟这个最小值交换位置，这样就能确定第一位最小值，然后第二次循环也是如此，以此类推就能按照由小到大排序。 还是对这几个数字进行排序：3 9 6 2 第一次循环：2 9 6 3 第二次循环：2 3 6 9 代码实现（java） public class XZTest { public static void main(String[] args) { int[] numbers = {3, 9, 6, 2}; int temp=0; for (int i = 0; i &lt; numbers.length; i++) { int min = i; for (int j = i + 1; j &lt; numbers.length; j++) { if(numbers[j]&lt; numbers[min]){ min=j; } } if(i!=min){ temp=numbers[i]; numbers[i]=numbers[min]; numbers[min]=temp; } } for(int i=0;i&lt;numbers.length;i++){ System.out.println(&quot;第&quot;+i+&quot;个数字是：&quot;+numbers[i]); } } } 输出结果是一样对： 第0个数字是：2 第1个数字是：3 第2个数字是：6 第3个数字是：9 ","link":"http://xuanguofeng.com/post/Java常用排序算法冒泡排序与选择排序总结/"},{"title":"Material Design风格输入样式TextInputLayout使用","content":"TextInputLayout是Google基于Material Design风格出现的一个文本输入布局。主要特点在样式上，官方第一句介绍是当输入的文本显示或者隐藏的时候，EditText显示浮动标签的布局。 先看看样式 样式其实是有动画效果的 使用方法 引入包环境 由于这个控件在这个android.support.design.widget包下，所以要查看是否已经引入了: compile ‘com.android.support:design:22.2.0’ compile ‘com.android.support:appcompat-v7:22.2.0’ 版本可根据需求自行调整 在布局中加入代码 &lt;android.support.design.widget.TextInputLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.design.widget.TextInputEditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;@string/form_username&quot;/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 样式修改 将默认的AppTheme主体添加如下属性 &lt;item name=&quot;android:textColorHint&quot;&gt;@colorcommonTextColorWhite&lt;/item&gt; &lt;item name=&quot;colorControlNormal&quot;&gt;@colorcommonTextColorWhite&lt;/item&gt; &lt;item name=&quot;colorControlActivated&quot;&gt;@colorcommonTextColorWhite&lt;/item&gt; &lt;item name=&quot;colorControlHighlight&quot;&gt;@colorcommonTextColorWhite&lt;/item&gt; 解释： 属性 含义 android:textColorHint 提示字体的颜色 colorControlNormal 下划线没有获取焦点，也就是默认的颜色 colorControlActivated 点击时下划线的颜色 计数器功能 使用 TextInputLayout还实现了输入时候记录输入字符数的功能，可以通过设置参数实现,导入如下环境 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; 添加如下属性 app:counterEnabled=&quot;true&quot; app:counterMaxLength=&quot;11&quot; app:counterTextAppearance=&quot;@style/text_style&quot; 属性 含义 app:counterEnabled 是否开启此功能 app:counterMaxLength 计数器限制的最大值 app:counterTextAppearance 计数器的字体样式 错误提示功能 TextInputLayout还有个错误提示的功能，可以直接通过api使用。 添加如下代码 app:errorEnabled=&quot;true&quot; app:errorTextAppearance=&quot;@style/error_text_style&quot; 在java代码中设置 textInputLayout.setError(&quot;这是textInputLayout的错误提示&quot;); mobile.setError(&quot;这是EditText的错误提示&quot;); 密码可视功能 将inputType的类型设置为password之后，可以通过设置如下属性。而且默认效果支持Material Design效果和默认动画，也是酷酷的。 app:passwordToggleEnabled=&quot;true&quot; app:passwordToggleTint=&quot;@color/colorAccent&quot; 属性 含义 app: passwordToggleEnabled 是否开启密码可视的功能 app: passwordToggleTint 修改提示图标的颜色 总结 google继Android5.0后出了一系列Material Design风格的控件，也引起了部分web端与Android端的的Material Design风格化。个人认为这也是一个比较好的设计语言。如果利用的好，将会对APP的交互很有利。 ","link":"http://xuanguofeng.com/post/Design风格文本输入样式TextInputLayout的使用 (xuanguoengdeMBP 的冲突副本 2020-03-17)/"},{"title":"Material Design风格输入样式TextInputLayout使用","content":"TextInputLayout是Google基于Material Design风格出现的一个文本输入布局。主要特点在样式上，官方第一句介绍是当输入的文本显示或者隐藏的时候，EditText显示浮动标签的布局。 先看看样式 样式其实是有动画效果的 使用方法 引入包环境 由于这个控件在这个android.support.design.widget包下，所以要查看是否已经引入了: compile ‘com.android.support:design:22.2.0’ compile ‘com.android.support:appcompat-v7:22.2.0’ 版本可根据需求自行调整 在布局中加入代码 &lt;android.support.design.widget.TextInputLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.design.widget.TextInputEditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;@string/form_username&quot;/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 样式修改 将默认的AppTheme主体添加如下属性 &lt;item name=&quot;android:textColorHint&quot;&gt;@colorcommonTextColorWhite&lt;/item&gt; &lt;item name=&quot;colorControlNormal&quot;&gt;@colorcommonTextColorWhite&lt;/item&gt; &lt;item name=&quot;colorControlActivated&quot;&gt;@colorcommonTextColorWhite&lt;/item&gt; &lt;item name=&quot;colorControlHighlight&quot;&gt;@colorcommonTextColorWhite&lt;/item&gt; 解释： 属性 含义 android:textColorHint 提示字体的颜色 colorControlNormal 下划线没有获取焦点，也就是默认的颜色 colorControlActivated 点击时下划线的颜色 计数器功能 使用 TextInputLayout还实现了输入时候记录输入字符数的功能，可以通过设置参数实现,导入如下环境 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; 添加如下属性 app:counterEnabled=&quot;true&quot; app:counterMaxLength=&quot;11&quot; app:counterTextAppearance=&quot;@style/text_style&quot; 属性 含义 app:counterEnabled 是否开启此功能 app:counterMaxLength 计数器限制的最大值 app:counterTextAppearance 计数器的字体样式 错误提示功能 TextInputLayout还有个错误提示的功能，可以直接通过api使用。 添加如下代码 app:errorEnabled=&quot;true&quot; app:errorTextAppearance=&quot;@style/error_text_style&quot; 在java代码中设置 textInputLayout.setError(&quot;这是textInputLayout的错误提示&quot;); mobile.setError(&quot;这是EditText的错误提示&quot;); 密码可视功能 将inputType的类型设置为password之后，可以通过设置如下属性。而且默认效果支持Material Design效果和默认动画，也是酷酷的。 app:passwordToggleEnabled=&quot;true&quot; app:passwordToggleTint=&quot;@color/colorAccent&quot; 属性 含义 app: passwordToggleEnabled 是否开启密码可视的功能 app: passwordToggleTint 修改提示图标的颜色 总结 google继Android5.0后出了一系列Material Design风格的控件，也引起了部分web端与Android端的的Material Design风格化。个人认为这也是一个比较好的设计语言。如果利用的好，将会对APP的交互很有利。 ","link":"http://xuanguofeng.com/post/Design风格文本输入样式TextInputLayout的使用/"},{"title":"工欲善其事必先利其器-android Studio技巧与插件","content":"本章是总结Android Studio的技巧与插件，俗话说工欲善其事必先利其器，对Android Studio使用的得心应手的话，将会大大提升工作效率与开发效率。 Android Studio常用技巧 多窗口拆分开发 应用场景：例如开发Activity要参考xml或者需要同时编写String.xml文件的时候。可以拆分横向、纵向。 使用方式：菜单栏---&gt;window---&gt;Editor Tabs---&gt;Split Horizontally(横向) 查看一个类的的结构 应用场景：有时候需要查看这个类的大概结构方法等。 使用方式:快捷键 mac:commmand+F12 win:ctrl+F12 查看一个方法被哪里调用 快捷键：Mac: option+ f7 win: alt+f7 或者单击右键选择 find usages 场景：不解释了应该很常用 查看一个方法描述注释 快捷键： mac: f1 将代码添加书签 场景：经常会需要记下这个位置代码以后方便时查看。 快捷键 ：mac :f3 win : f11 Android Studio 代码分析功能 使用场景：google建议的代码，应该不会太差吧。 使用方式：菜单栏----&gt;Analyze----&gt;Inspect Code 会有些建议性的提示。 代码模板 使用场景：有些代码是经常使用到的格式，复用性很强。 例如：判空，循环，快速编写swich等。 ####预览方法定义 场景：有时候想看一个方法是怎么实现的，会快速弹出一个框。 快捷键：mac: command+Y ####给断点设置条件 例如：for循环只想=5的时候打断点 单击断点右键既可以设置条件。 ####运行过程中快速断点 例如：app正在运行，出现bug不想重新跑项目的时候。 ####快速查看方法详情 command+B ####查找参数定义与文档 command +P Android Studio常用插件 Translation 快速翻译 设置快捷键可以直接翻译包括log，英汉 汉英。 ADB WIFI 可以无线调试的一个插件 GsonFormat 快速实现bean类。 ","link":"http://xuanguofeng.com/post/工欲善其事必先利其器-android Studio技巧与插件 (xuanguoengdeMBP 的冲突副本 2020-03-17)/"},{"title":"工欲善其事必先利其器-android Studio技巧与插件","content":"本章是总结Android Studio的技巧与插件，俗话说工欲善其事必先利其器，对Android Studio使用的得心应手的话，将会大大提升工作效率与开发效率。 Android Studio常用技巧 多窗口拆分开发 应用场景：例如开发Activity要参考xml或者需要同时编写String.xml文件的时候。可以拆分横向、纵向。 使用方式：菜单栏---&gt;window---&gt;Editor Tabs---&gt;Split Horizontally(横向) 查看一个类的的结构 应用场景：有时候需要查看这个类的大概结构方法等。 使用方式:快捷键 mac:commmand+F12 win:ctrl+F12 查看一个方法被哪里调用 快捷键：Mac: option+ f7 win: alt+f7 或者单击右键选择 find usages 场景：不解释了应该很常用 查看一个方法描述注释 快捷键： mac: f1 将代码添加书签 场景：经常会需要记下这个位置代码以后方便时查看。 快捷键 ：mac :f3 win : f11 Android Studio 代码分析功能 使用场景：google建议的代码，应该不会太差吧。 使用方式：菜单栏----&gt;Analyze----&gt;Inspect Code 会有些建议性的提示。 代码模板 使用场景：有些代码是经常使用到的格式，复用性很强。 例如：判空，循环，快速编写swich等。 ####预览方法定义 场景：有时候想看一个方法是怎么实现的，会快速弹出一个框。 快捷键：mac: command+Y ####给断点设置条件 例如：for循环只想=5的时候打断点 单击断点右键既可以设置条件。 ####运行过程中快速断点 例如：app正在运行，出现bug不想重新跑项目的时候。 ####快速查看方法详情 command+B ####查找参数定义与文档 command +P Android Studio常用插件 Translation 快速翻译 设置快捷键可以直接翻译包括log，英汉 汉英。 ADB WIFI 可以无线调试的一个插件 GsonFormat 快速实现bean类。 ","link":"http://xuanguofeng.com/post/工欲善其事必先利其器-android Studio技巧与插件/"},{"title":"Android沉浸式状态栏方法总结","content":"为什么用沉浸式状态栏？ 也不知道从什么时候开始大部分的App已经全部向沉浸式状态栏靠拢，这种效果应该是想让最顶部的状态栏和项目的标题栏过渡比较融和吧。 不过沉浸式状态栏这种叫法可能不太妥当。 本篇文章参考郭霖的博客。 郭霖博客地址：Android状态栏微技巧，带你真正理解沉浸式模式 第一种实现方式 其实主要实现的就是顶部状态栏和toolbar的颜色一致达到效果。 &lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 其中 colorPrimaryDark这个参数就是设置状态栏的颜色，设置状态栏和toolbar或者自定义的标题栏颜色一致的话会显示 第二种实现方式 第二种实现方式是把主题布局往上移动，把布局从屏幕的左上角开始计算。所以这种方式需要注意，把顶部状态栏的高度要计算在出来。 if (Build.VERSION.SDK_INT &gt;= 21) { View decorView = getWindow().getDecorView(); int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE; decorView.setSystemUiVisibility(option); getWindow().setStatusBarColor(Color.TRANSPARENT); } //隐藏标题栏 ActionBar actionBar = getSupportActionBar(); actionBar.hide(); 第三种实现方式 第三种表面看来是全屏的方式，然后可以通过滑动顶部来实现状态栏的弹出，然后会自动隐藏掉。这种模式也是真正意义的沉浸式状态栏。 git效果：http://note.youdao.com/share/?id=fdc645c84ad9cd4e4ba0841b116a703c&amp;type=note#/ 实现方式：在Activity中实现如下方法 @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); if (hasFocus &amp;&amp; Build.VERSION.SDK_INT &gt;= 19) { View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY); } } ","link":"http://xuanguofeng.com/post/Android沉浸式状态栏方法总结/"},{"title":"Android中创建so库存储密钥，NDK环境搭建与jni介绍","content":"介绍 so库介绍：Android开发中经常会见到jinLibs文件夹下的so库文件，就算用第三方的sdk也会经常看到so库，so库是一个用c/c++语言些的函数库。Android中可以用过使用jni的方式来调取so库。在某些方面so函数库可能会更高效更安全。 JNI介绍：Java Native Interface，它是Java平台的一个特性(并不是Android系统特有的)。其实主要是定义了一些JNI函数，让开发者可以通过调用这些函数实现Java代码调用C/C++的代码，C/C++的代码也可以调用Java的代码，JNI也有些自己的语法和函数。 NDK介绍：NDK是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。以下是google官方对于NDK的介绍 The Native Development Kit (NDK) is a set of tools that allows you to use C and C++ code with Android, and provides platform libraries you can use to manage native activities and access physical device components, such as sensors and touch input. The NDK may not be appropriate for most novice Android programmers who need to use only Java code and framework APIs to develop their apps. However, the NDK can be useful for cases in which you need to do one or more of the following: Squeeze extra performance out of a device to achieve low latency or run computationally intensive applications, such as games or physics simulations. Reuse your own or other developers' C or C++ libraries. 在AndroidStudio中配置NDK环境 1.下载 也可以直接在官方网站下载zip不过需要科学上网哦！ 官网地址：https://developer.android.com/ndk/downloads/index.html local.properties文件中出现ndk.dir则配置成功。 2.配置gradle.properties文件，添加android.useDeprecatedNdk=true 这样NDK环境就搭建ok了。 Java、C/C++代码编写以及so的生成与使用 1.创建对应的java类 package com.xuanguofeng.t2_ndk; public class JniUtil { static { //jniutil这个参数对应着c的文件名，以及后面的配置名以及so的库名称 System.loadLibrary(&quot;jniutil&quot;); } //c/c++中要对应实现的方法，必须声明native public native String getKey(String key); } 2.对项目进行编译 编译后对项目会在文件夹下出现class文件 2.生成.h文件 打开Android Studio的Terminal也可以在对应目录的命令窗口中，切换到项目的app/src/main目录下，执行命令： javah -d jni -classpath 编译后的class文件的绝对路径 .h文件会在app目录下的jni文件夹中，如果在不同的目录下执行命令会在不同的目录中生成jni文件夹 3.编写.c/.cpp文件 .c/.cpp文件的文件名要与之前在java类中定义的System.loadLibrary(&quot;jniutil&quot;);中的“jniutil”一致。 说明：.c文件对应的c语言,.cpp对应的是c++语言。 #include&quot;com_xuanguofeng_t2_ndk_JniUtil.h&quot; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; char *RELEASE_SIGN = &quot;330818b310f300d0660355040a0c0ce7acace4b880e8bda6e7bd9131b7f5d1bd5e607ecdc1d9a0fef8eec91b621d6071a10af23135bd3d7115865f3e5859d8f7d44b78479adeb071f48d91eb162aced5510cddc106734d152c75db1622cfdb935d7213817589d7c4a33f829c9d74ff0dd008caa9f705e30550be64fe22887373644bbb63134ec1aff680171214643cb8d1c7e5...&quot;; char *APK_SIGN_ERROR = &quot;签名不一致&quot;; char *a = &quot;a&quot;; #... 这里可以定义更多的干扰字符 char *b = &quot;b&quot;; char *c = &quot;c&quot;; char *d = &quot;d&quot;; char *e = &quot;e&quot;; char *f = &quot;f&quot;; char *g = &quot;g&quot;; char *x = &quot;x&quot;; char *y = &quot;y&quot;; char *z = &quot;z&quot;; char *i1 = &quot;1&quot;; char *i2 = &quot;2&quot;; char *i3 = &quot;3&quot;; char *i4 = &quot;4&quot;; char *i5 = &quot;5&quot;; char *i6 = &quot;6&quot;; char *i7 = &quot;7&quot;; char *i8 = &quot;8&quot;; char *i9 = &quot;9&quot;; char *i0 = &quot;0&quot;; JNIEXPORT jstring JNICALL Java_com_xuanguofeng_t2_1ndk_JniUtil_getKey (JNIEnv *env, jobject obj, jstring appkey) { char *rtn = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;utf-8&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, (Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray) env-&gt;CallObjectMethod(appkey, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte *ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) { rtn = (char *) malloc(alen + 1); memcpy(rtn, ba, alen); rtn[alen] = 0; } env-&gt;ReleaseByteArrayElements(barr, ba, 0); if (strcmp(RELEASE_SIGN, rtn) == 0) { char ack[6] = &quot;&quot;; strcat(ack, i1); strcat(ack, i2); strcat(ack, i3); strcat(ack, i4); strcat(ack, i5); strcat(ack, i6); return env-&gt;NewStringUTF(ack); } else { return env-&gt;NewStringUTF(APK_SIGN_ERROR); } } 代码说明： RELEASE_SIGN是定一个了一个key的变量，这个key固定在so里面 是通过keystore文件生成的后面会讲解方法。原因是如果直接单纯的返回密钥，拿到so一样不是那么安全，只有通过对应的签名文件验证通过后才会返回具体的密钥。这里返回的ack变量则是要返回给java的密钥。 说明：由于本次不怎么懂c所以只是通过查询资料简单的对密钥进行打乱拼接。读者可自行优化c算法。如有建议或者纠正欢迎留言。 4.在app目录下的build.gradle文件中添加如下代码 ndk { moduleName &quot;jniutil&quot; abiFilters 'armeabi', 'x86', 'armeabi-v7a' } 注意：此处的moduleName还是与之前配置的 System.loadLibrary(&quot;jniutil&quot;); 中的jniutil一直。 5.在activity调用库中的方法。 package com.xuanguofeng.t2_ndk; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.Signature; import android.support.v7.app.AppCompatActivity; import android.os.Bundle;import android.util.Log; import android.widget.TextView; public class MainActivity extends AppCompatActivity { private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView= (TextView) findViewById(R.id.text); try { PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES); Signature[] signs = packageInfo.signatures; Signature sign = signs[0]; textView.setText(new JniUtil().getKey(sign.toCharsString())); } catch (Exception e) { e.printStackTrace(); } }} 代码说明： sign.toCharsString()这个方法就是获取keystore中的值来和so库中的进行比较。开发时候debug的和正式发布的keystore值是不一样的所以要注意更换。 这时候点击运行项目如果签名一致就会打印密钥，如果不一致就会打印签名错误。 6.so的使用 在main文件夹下创建jniLibs有的项目会放在libs中，但是需要在gradle中配置目录，其实是一样的，复制我们之前生成的so文件。复制对应的JniUtil类注意，包名要与之前创建的so时的包名一致。之前的jni文件下的.h和c/c++源文件以及gradle里面配置的ndk信息也都不需要了。 当然 关于ndk，jni，so的相关知识可能还有很多推荐几篇文章给大家参考。 jni讲解：http://www.jianshu.com/p/aba734d5b5cd NDK下载：https://developer.android.com/ndk/downloads/index.html google官方NDK介绍：https://developer.android.google.cn/ndk/guides/index.html ","link":"http://xuanguofeng.com/post/Android中创建so库存储密钥，NDK环境搭建与jni介绍/"},{"title":"Android动画共享元素(例列表图片放大到详情图片动画)","content":"什么是共享元素 简单来说共享元素就是两个Activity中都拥有此元素，在第二个Activity中进行强调而展示一些的动画效果。例如圆按钮的漂移动画。图片的放大动画。 为什么使用共享元素 主要是因为在Android5.0以后google推出了 Material Design的设计风格，在Adnroid 5.0之后的api中也添加了很多关于这个风格的主题以及控件，也更推崇两个控件之间的自然的转场动画。使页面更加自然，炫丽。 效果展示 简书似乎好像不支持gif请打开查看效果： http://note.youdao.com/noteshare?id=dcb19ac9c6b32e297c1441fa1bab821f 使用方法 1.在第一个Activity中的控件添加如下属性： android:transitionName=&quot;button&quot; &lt;ImageView android:id=&quot;@+id/s2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;#00ff00&quot; android:transitionName=&quot;image&quot; /&gt; 2.在第二个Activity中同样添加这个属性： 注意：这个名字必须一致。 3.使用intnet跳转即可 startActivity(intent, ActivityOptions.makeSceneTransitionAnimation( MainActivity.this,v,&quot;image&quot;).toBundle()); 这里的image参数就是在android:transitionName配置的。这样我们便实现此功能。其实很简单。 这个属性应该还支持其他的一些控件，比如按钮button等，具体的效果应该也还有其他的效果，可以自行查阅官方api。 ","link":"http://xuanguofeng.com/post/Android动画共享元素(例列表图片放大到详情图片动画)/"},{"title":"Android拍照或从系统相册获取图片","content":"概述 在做Android开发中还是会经常选择照片然后做上传操作的。但是其中选择照片系统的有两种方式，第一种是拍照、第二种是从相册中选择。这里分别介绍下。 其中拍照有两种方法，从系统相册选择有两种方法，会分别介绍和分析。 拍照获取照片的方法 刚才说过会介绍两种方法，其实无论几种方法原理都是一个。就是通过intent发出隐式意图调用系统的照相机，然后在获取到从相机返回的图片，这里的两种主要是返回方式有两种。 1、直接返回图片。 2、提前创建好存放图片的Uri然后拍照返回后存储起来。 第一种拍照方法： Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); startActivityForResult(intent, TAKE_PHOTO_REQUEST); 没错，简单的两行代码就可以调取摄像头进行拍照了，这时候我们是通过Intent指定activion: MediaStore.ACTION_IMAGE_CAPTURE去查找符合条件的程序。相机里面会对这个action做处理，这一步属于intent的操作了，这里不再赘述。 case TAKE_PHOTO_REQUEST: if (resultCode == RESULT_CANCELED) { Toast.makeText(MainActivity.this, &quot;取消了拍照&quot;, Toast.LENGTH_LONG).show(); return; } Bitmap photo = data.getParcelableExtra(&quot;data&quot;); iv_image.setImageBitmap(photo); break; 上面的代码是onActivityResult中的处理，判断request后做拍照返回处理，其中data直接返回Bitmap,不过这里要注意一点就是，这个Bitmap会经过系统压缩。所以有时候可能看起来照片并没有那么清晰。也正是由于是系统压缩的原因，这个图片基本不会很大，基本不会OOM。 第二种拍照获取照片方法： 第二种方法其实也是一样的，只不过我们事先定义好uri,然后图片会存储到这个uri中，然后我们可以通过这个uri在本地找到具体的图片，然后做处理，展示。 private static Uri createImageUri(Context context) { String name = &quot;takePhoto&quot; + System.currentTimeMillis(); ContentValues contentValues = new ContentValues(); contentValues.put(MediaStore.Images.Media.TITLE, name); contentValues.put(MediaStore.Images.Media.DISPLAY_NAME, name + &quot;.jpeg&quot;); contentValues.put(MediaStore.Images.Media.MIME_TYPE, &quot;image/jpeg&quot;); Uri uri = context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues); return uri; } 上述代码是创建一个uri用来存储拍照后的照片。 public static void delteImageUri(Context context, Uri uri) { context.getContentResolver().delete(uri, null, null); } 上述代码是用来删除一个本地uri btn_take_photo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { imageUri = createImageUri(MainActivity.this); Intent intent = new Intent(); intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE); intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);//如果不设置EXTRA_OUTPUT getData() 获取的是bitmap数据 是压缩后的 startActivityForResult(intent, TAKE_PHOTO_REQUEST_ONE); } }); 然后通过上述代码创建imageUri然后发起拍照，方式同样用Intent,可参第一种方法。 if (resultCode == RESULT_CANCELED) { delteImageUri(MainActivity.this,imageUri); return; } case TAKE_PHOTO_REQUEST_ONE: iv_image.setImageURI(imageUri); break; 最后就是获取拍照的照片做处理或者显示。 其中如果取消的话就删除创建的rui。 Bitmap bitmap=MediaStore.Images.Media.getBitmap(getContentResolver(),imageUri); iv_image.setImageBitmap(bitmap); 还可以直接通过MediaStore获取bitmap进行设置。 以上方法经测试在可以正常获取照片。 但是这样还会有个问题，就是如果图片过大的情况下，会有异常。 W/OpenGLRenderer: Bitmap too large to be uploaded into a texture (3120x4208, max=4096x4096) 如上代码所示，会直接报bitmap的过大而无法显示图片。 第一种处理方法就是对图片进行处理。 这里介绍第二种处理方式，就是用不同的方式去创建存储图片的文件。 public class TakePhotoUtils { /** * 拍照 */ public static Uri takePhoto(Activity mActivity, int flag) throws IOException { //指定拍照intent Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); Uri imageUri = null; if (takePictureIntent.resolveActivity(mActivity.getPackageManager()) != null) { String sdcardState = Environment.getExternalStorageState(); File outputImage = null; if (Environment.MEDIA_MOUNTED.equals(sdcardState)) { outputImage = createImageFile(mActivity); } else { Toast.makeText(mActivity.getApplicationContext(), &quot;内存异常&quot;, Toast.LENGTH_SHORT).show(); } try { if (outputImage.exists()) { outputImage.delete(); } outputImage.createNewFile(); } catch (IOException e) { e.printStackTrace(); } if (outputImage != null) { imageUri = Uri.fromFile(outputImage); takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); mActivity.startActivityForResult(takePictureIntent, flag); } } return imageUri; } public static File createImageFile(Activity mActivity) throws IOException { String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date()); String imageFileName = &quot;JPEG_&quot; + timeStamp;//创建以时间命名的文件名称 File storageDir = getOwnCacheDirectory(mActivity, &quot;takephoto&quot;);//创建保存的路径 File image = new File(storageDir.getPath(), imageFileName + &quot;.jpg&quot;); if (!image.exists()) { try { //在指定的文件夹中创建文件 image.createNewFile(); } catch (Exception e) { } } return image; } /** * 根据目录创建文件夹 * @param context * @param cacheDir * @return */ public static File getOwnCacheDirectory(Context context, String cacheDir) { File appCacheDir = null; //判断sd卡正常挂载并且拥有权限的时候创建文件 if ( Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) &amp;&amp; hasExternalStoragePermission(context)) { appCacheDir = new File(Environment.getExternalStorageDirectory(), cacheDir); } if (appCacheDir == null || !appCacheDir.exists() &amp;&amp; !appCacheDir.mkdirs()) { appCacheDir = context.getCacheDir(); } return appCacheDir; } /** * 检查是否有权限 * @param context * @return */ private static boolean hasExternalStoragePermission(Context context) { int perm = context.checkCallingOrSelfPermission(&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;); return perm == 0; } } 代码没什么难点，简单写了一个工具类，里面封装了一个拍照的方法，并返回一个存储拍照后的路径。 路径是自己制定文件夹后创建一个文件，用于存储照片。文件名是根据时间命名的，以免重复。 if (resultCode == RESULT_CANCELED) { Toast.makeText(MainActivity.this, &quot;点击取消从相册选择&quot;, Toast.LENGTH_LONG).show(); return; } Bitmap bitmap = BitmapFactory.decodeFile(imageUri.getPath(), getOptions(imageUri.getPath())); iv_image.setImageBitmap(bitmap); 然后在onActivityResult的方法中进行处理，这里也最好对图片进行下压缩处理。然后就可以正常显示拍照后的图片了。 /** * 获取压缩图片的options * * @return */ public static BitmapFactory.Options getOptions(String path) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(path, options); options.inPreferredConfig = Bitmap.Config.RGB_565; options.inSampleSize = 4; //此项参数可以根据需求进行计算 options.inJustDecodeBounds = false; return options; } 这里的只是简单的处理方法，按照指定参数压缩下，这里的inSapleSizes是需要根据自己需求进行算法的。 这样基本就可以通过拍照来获取照片了 从相册选择照片来展示 其实拍照主要也是通过intent来调用系统相册，然后通过返回数据在onActivityResult中进行处理。 public void pickImageFromAlbum() { Intent intent = new Intent(); intent.setAction(Intent.ACTION_GET_CONTENT); intent.setType(&quot;image/*&quot;); startActivityForResult(intent, 111); } public void pickImageFromAlbum2() { Intent intent = new Intent(); intent.setAction(Intent.ACTION_PICK); intent.setData(MediaStore.Images.Media.EXTERNAL_CONTENT_URI); startActivityForResult(intent, 222); } 如图两种方式均可以调用系统相册进行选择照片。 if (resultCode == RESULT_CANCELED) { Toast.makeText(MainActivity.this, &quot;点击取消从相册选择&quot;, Toast.LENGTH_LONG).show(); return; } try { Uri imageUri = data.getData(); Log.e(&quot;TAG&quot;, imageUri.toString()); iv_image.setImageURI(imageUri); } catch (Exception e) { e.printStackTrace(); } 然后返回的处理方式基本是一样的 拿到uri后进行对图片处理就好了。这里说明下如果图片过大可能也需要进行二次处理。 如本篇有错误欢迎大家留言指正。 demo源码地址:https://github.com/xuanguofeng/TakeAndChoosePhoto ","link":"http://xuanguofeng.com/post/Android拍照或从系统相册获取图片/"},{"title":"Android布局优化merge、ViewStub的用法","content":"描述 由于在Android开发工程中需要开发很多界面，每个界面又是以xml布局的形式进行加载。所以在加载这些布局文件的时候是一个开销很大的过程。因此我们在写布局文件的时候需要考虑一些优化来加快程序的性能. 性能方面优化 尽量避免多层次的嵌套，因为布局可以无限制的进行嵌套。所以写起来难免有些肆无忌惮，但是布局结构尽量要避免多层次的嵌套来减少开销。数量应最多不要超过10层。 使用merge标签 如图，使用merge标签可以减少多余的层次结构，多用于一个布局需要包含另一个布局的时候，或者这一个布局用到的重复样式比较多。在加载merge标签的时候，不会加载父控件，只会加载merge标签中的子view。merge标签结合include一起使用可以灵活的、可复用性强的创建布局。 避免过多的view，填充每个view都要花费一些资源和时间，为了更快速加载，应尽量减少view的加载。如果布局包含的view个数超过80，填充布局花费的时间将成为一个显著的问题。 使用ViewStub ViewStub有一个比较大的优点就是当你用到这个布局的时候才会去加载，例如我们在布局里写了ViewStub并引用一个我们写好的布局。这时候我们可以在我们的activity中使用的时候，必须先设置visible。 这样这个布局才会被加载显示。否则是不会显示的。为了防止都findViewById 方法，我们可以调用inflate()方法，这个方法会返回一个view，我们可以直接对这个view进行操作。 代码可视性的优化。 写布局的时候，可以尽量在父控件中做操作，这样会影响到每个子view。例如，我们经常写距离左边距，这个时候一个在父母局中写一次，而不是在每个子控件中都写一遍。 写线性布局的时候可以使用权重，这样也会对屏幕适配起作用。 Android studio中可以直接对多次重用的空间进行属性抽取。 如图，抽取的属性将会在style中，我们在布局文件中就可以直接引用。多次需要用到这个属性的时候我们可以直接用一行代码引用即可。 使用include标签，来引用比较复杂，或者抽象的布局文件。 ","link":"http://xuanguofeng.com/post/Android布局优化merge、ViewStub的用法/"}]}